\chapter{Data model}\label{ch:data-model}

As noted in chapter \ref{ch:welcome-to-python}, writing programs for
financial modelling involves more than numerical analysis alone. Designing 
a trade representation is a case in point and the focus of this
chapter. From experience, if we get the design of the trade
description correct, then the rest of the analytics framework falls
naturally into place.

In finance a financial contract is commonly called a trade. Trades are
built from legs and exercise schedules. A leg is a collection of cash
flows, simply referred to as flows, and each cash flow can depend upon
an arbitrary number of market observables. An exercise schedule is a
collection of exercise decisions, simply referred to as exercises. Each 
exercise decision represents the right to either call or cancel the  
trade on a particular date. In the following sections we will go 
through each of these building blocks in turn, starting with observables.

\section{Observables}

As mentioned already, the cash flows of a financial instrument depend
upon the values of market observables. Examples of market observables
are
\begin{inparaenum}
\item[(i)]{the spot price of an asset (e.g. stock, index or commodity)}, 
\item[(ii)]{the fixing of an interest rate (e.g. LIBOR\footnote{LIBOR
is discussed in section \ref{sec:libor}})} or,
\item[(iii)]{the measured rainfall over a certain period in a given location.}
\end{inparaenum}
Associated with an observable is its time of observation, normally
called its \emph{reset} date. Before the \emph{reset} date, the observable 
isn't known and has to be estimated but on the \emph{reset} date the market 
publishes a value for the observable. An observable with a \emph{reset} date in the
past is deemed to have been \emph{fixed}. The \verb|ppf.core.fixing|
module encapsulates this simple idea:
\begin{verbatim}
class fixing:
  def __init__(self, is_fixed=False, value=None):
    self.__is_fixed = is_fixed
    self.__value = value
  def is_fixed(self): return self.__is_fixed
  def value(self): return self.__value
\end{verbatim}

While the universe of observables is rich and varied, all observables
have some properties in common. The class \verb|observable_base| from
the \verb|ppf.core.observable_base| module encodes these common
properties:
\begin{verbatim}
class observable_base:
  def __init__(self
             , attributes
             , flow_id
             , reset_id
             , reset_ccy
             , reset_date
             , last_important_date
             , fix
             , spread):
    self.__attributes = attributes
    self.__flow_id = flow_id
    self.__reset_id = reset_id
    self.__reset_ccy = reset_ccy
    self.__reset_date = reset_date
    self.__last_important_date = last_important_date
    self.__fix = fix
    self.__spread = spread
  def flow_id(self): return self.__flow_id
  def reset_id(self): return self.__reset_id
  def reset_currency(self): return self.__reset_ccy
  def reset_date(self): return self.__reset_date
  def last_important_date(self): return self.__last_important_date
  def spread(self): return self.__spread
  def fix(self) : return self.__fix
  def attributes(self) : return self.__attributes
\end{verbatim}
Associated with every observable is a flow id, a reset id, a reset
currency, a reset date, a last important date, a fixing and a
spread. The flow id refers to the index of the flow in a sequence of
flows that is associated with the observable. The reset id
refers to the index of the observable in the collection of observables
associated with the referenced flow. The reset currency can be a
traded currency such as USD for an interest rate observable, or a pair
of currencies such as GBPUSD for a foreign exchange observable, or the
currency associated with an equity index such as EUR for DAX. The
reset date represents the date of observation. If the date of
observation is in the past, then the observable will require a
fixing. In the event that the fixing is missing, a runtime exception
will be raised in the \verb|ppf| pricing framework. The last important
date is typically equal to the reset date but for some observables
such as swap rates, it represents the last important date required to
be known in order to calculate its value. It is not uncommon
for a financial transaction to be dependent on the value of an
observable plus or minus a spread which explains the presence of the 
last parameter in the constructor. The first parameter of the
constructor, \verb|attributes|, is for future extension: In section
\ref{sec:swap-rate} we will encounter a concrete use case for the 
\verb|attributes| parameter.

The class \verb|observable| from the \verb|ppf.core.observable| module
is an extension point and the actual root from which concrete
\verb|ppf| observables inherit.
\begin{verbatim}
from observable_base import *

class observable(observable_base):
  def __init__(self
             , attributes
             , flow_id
             , reset_id
             , reset_ccy
             , reset_date
             , last_important_date
             , fix
             , spread):
    observable_base.__init__(self
                           , attributes
                           , flow_id
                           , reset_id
                           , reset_ccy
                           , reset_date
                           , last_important_date
                           , fix
                           , spread)      
\end{verbatim}
In the following two sub-sections we present two examples of market
observables.

\subsection{LIBOR}\label{sec:libor}
In the world of interest rate trading, one frequently observed
quantity on which a payoff may depend is the
\emph{LIBOR}\footnote{London Interbank Offer Rate -- a daily reference
rate on which banks in the London money market offer to lend each
other unsecured funds.}
rate. The class \verb|libor| in module \\
\verb|ppf.core.libor_rate| offers an implementation of the LIBOR
observable. The \verb|libor_rate| constructor takes in the properties
common to all observables plus the projection start and end date
together with the projection basis. The projection period defined by
the difference between the projection end date and start date,
determines the period over which the LIBOR rate is to apply. As an
example, for GBP LIBOR the projection period, is six
months. Furthermore, there is usually a lag between the date on which
the rate is set and the beginning of the projection period. Once again, as
an example, for GBP LIBOR the lag is two business days. 

\begin{verbatim}
from ppf.date_time import year_fraction
from fixing import *
from observable import *

class libor_rate(observable):
  def __init__(self
             , attributes
             , flow_id
             , reset_id
             , reset_date
             , reset_currency
             , proj_start_date
             , proj_end_date
             , proj_basis
             , fix
             , spread=None):
    observable.__init__(self
                      , attributes
                      , flow_id
                      , reset_id
                      , reset_currency
                      , reset_date
                      , proj_end_date
                      , fix
                      , spread)
    self.__proj_start_date = proj_start_date
    self.__proj_end_date = proj_end_date
    self.__proj_basis = proj_basis

  def proj_start_date(self): return self.__proj_start_date
  def proj_end_date(self): return self.__proj_end_date
  def proj_basis(self): return self.__proj_basis

  def year_fraction(self):
    return year_fraction(self.__proj_start_date
                       , self.__proj_end_date
                       , self.__proj_basis)

  def __str__(self):
      s = "%d, " %  self.flow_id()
      s += "%d, " % self.reset_id()
      s += "%s, " % self.reset_currency()
      s += "[%s, %s], " % (self.__proj_start_date, self.__proj_end_date)
      s += "%s, " % day_count_basis_strings[self.__proj_basis]
      fix = self.fix()
      if fix.is_fixed():
         s += "%f, " % fix.value()
      spread = self.spread()
      if spread <> None:
         s += "%f, " % spread
      return s

\end{verbatim}
For completeness the \verb|libor_rate| class provides a method \verb|forward| 
for determining the value of the libor rate at a particular point in time.
\begin{verbatim}
class libor_rate(observable):
  def forward(self, t, curve):
    fix = self.fix()
    if fix.is_fixed():
      return fix.value()

    start = self.__proj_start_date
    until = self.__proj_end_date
    Ts, Te = (int(start - t)/365.0, int(until - t)/365.0)
    Ps, Pe = (curve(Ts), curve(Te))
    dcf = year_fraction(start, until, self.__proj_basis)
    forward = (Ps/Pe-1.0)/dcf

    return forward
\end{verbatim}

In practice, it is frequently necessary to generate collections of
LIBOR observables. Accordingly the
\verb|ppf.core.generate_observables| module offers the function
\verb|generate_libor_observables()| for this purpose.
\begin{verbatim}
def generate_libor_observables(
   start
 , end
 , roll_period = 6
 , roll_duration = ppf.date_time.months
 , reset_period = 6
 , reset_duration = ppf.date_time.months
 , tenor_period = 6
 , tenor_duration = ppf.date_time.months
 , reset_currency = "USD"
 , reset_basis = ppf.date_time.basis_act_360
 , reset_holiday_centres = None
 , reset_shift_method = ppf.date_time.modified_following
 , reset_lag = 0
 , *arguments
 , **keywords):
  from ppf.date_time import days
  shift = ppf.date_time.shift

  if reset_lag > 0:
    raise RuntimeError, "index lag expected less or equal to zero"

  day, flow_id, all_observables = 0, 0, []
  while day < end:
      roll_start = start + roll_duration(flow_id*roll_period)
      roll_end = start + roll_duration((flow_id+1)*roll_period)
      reset_id = 0
      proj_roll = roll_start
      observables = []
      while proj_roll < roll_end:
           proj_start = shift(
                    proj_roll
                  , reset_shift_method, reset_holiday_centres)
           proj_end = shift(
                    proj_roll+tenor_duration(tenor_period)
                  , reset_shift_method, reset_holiday_centres)
           reset_date = shift(
                    proj_start+days(reset_lag)
                  , reset_shift_method, reset_holiday_centres)
           observables.append( 
                     libor_rate(None, flow_id,  reset_id, reset_date
                              , reset_currency, proj_start, proj_end
                              , reset_basis, fixing(False)))
           reset_id += 1
           proj_roll = roll_start+reset_duration(reset_id*reset_period) 
      day = roll_end
      all_observables.append(observables)
      flow_id += 1

  return all_observables
\end{verbatim}
Here is an example of \verb|generate_libor_observables()| in use.
\begin{verbatim}
  >>> observables = generate_libor_observables(
  ...     start  = date(2007, Jun, 29)
  ...   , end  = date(2012, Jun, 29)
  ...   , roll_period = 6
  ...   , roll_duration = ppf.date_time.months
  ...   , reset_period = 3
  ...   , reset_duration = ppf.date_time.months
  ...   , tenor_period = 3
  ...   , tenor_duration = ppf.date_time.months
  ...   , reset_currency = "JPY"
  ...   , reset_basis = basis_act_360
  ...   , reset_shift_method = shift_convention.modified_following)
  >>> for obs_per_flow in observables:
  ...  for obs in obs_per_flow:
  ...   print obs
  0, 0, JPY, [2007-Jun-29, 2007-Sep-28], basis_act_360, 
  0, 1, JPY, [2007-Sep-28, 2007-Dec-31], basis_act_360, 
  1, 0, JPY, [2007-Dec-31, 2008-Mar-31], basis_act_360, 
  1, 1, JPY, [2008-Mar-31, 2008-Jun-30], basis_act_360, 
  2, 0, JPY, [2008-Jun-30, 2008-Sep-29], basis_act_360, 
  2, 1, JPY, [2008-Sep-29, 2008-Dec-29], basis_act_360, 
  3, 0, JPY, [2008-Dec-29, 2009-Mar-30], basis_act_360, 
  3, 1, JPY, [2009-Mar-30, 2009-Jun-29], basis_act_360, 
  4, 0, JPY, [2009-Jun-29, 2009-Sep-29], basis_act_360, 
  4, 1, JPY, [2009-Sep-29, 2009-Dec-29], basis_act_360, 
  5, 0, JPY, [2009-Dec-29, 2010-Mar-29], basis_act_360, 
  5, 1, JPY, [2010-Mar-29, 2010-Jun-29], basis_act_360, 
  6, 0, JPY, [2010-Jun-29, 2010-Sep-29], basis_act_360, 
  6, 1, JPY, [2010-Sep-29, 2010-Dec-29], basis_act_360, 
  7, 0, JPY, [2010-Dec-29, 2011-Mar-29], basis_act_360, 
  7, 1, JPY, [2011-Mar-29, 2011-Jun-29], basis_act_360, 
  8, 0, JPY, [2011-Jun-29, 2011-Sep-29], basis_act_360, 
  8, 1, JPY, [2011-Sep-29, 2011-Dec-29], basis_act_360, 
  9, 0, JPY, [2011-Dec-29, 2012-Mar-29], basis_act_360, 
  9, 1, JPY, [2012-Mar-29, 2012-Jun-29], basis_act_360, 
\end{verbatim}
The sample invocation above has generated a sequence of LIBOR rate
observables. The sequence has been generated such that there are two
observables per flow each with a projection period of 3 months and
reset date equal to the projection start date.

\subsection{Swap rate}\label{sec:swap-rate}
Like the LIBOR rate of section \ref{sec:libor}, another commonly
observed quantity in interest rate structures is the swap rate. To
calculate the value of the swap rate we need to have a description of
the two legs making up the swap. The fixed leg is simply a collection
of flows paying a fixed coupon at regular intervals. Similarly the
funding leg is a collection of flows paying LIBOR at regular
intervals. We will properly define \emph{flows} in
section \ref{sec:flows} but, for now, we simply assume the existence of a
\verb|class flow| and function \verb|generate_flows()|. 
The class \verb|swap_rate| in module \verb|ppf.core.swap_rate|
provides an implementation of the swap rate. The constructor signature
is identical to that of the \verb|libor_rate| constructor. The
\verb|attributes| constructor parameter is expected to be a Python
dictionary and is used to store information relating to the fixed
and funding legs making up the swap. The constructor invokes the
\verb|__generate()| method which uses the information contained in
that dictionary together with the projection start and end dates to 
generate the underlying legs of the swap.
\begin{verbatim}
from fixing import *
from observable import *
from generate_flows import *
from generate_observables import *

class swap_rate(observable):
  def __init__(self
             , attributes
             , flow_id
             , reset_id
             , reset_date
             , reset_ccy
             , proj_start_date
             , proj_end_date
             , fix
             , spread=None):
    observable.__init__(self
                      , attributes
                      , flow_id
                      , reset_id
                      , reset_ccy
                      , reset_date
                      , proj_end_date
                      , fix
                      , spread)
    self.__proj_start_date = proj_start_date
    self.__proj_end_date = proj_end_date
    self.__generate()

  def proj_start_date(self): return self.__proj_start_date
  def proj_end_date(self): return self.__proj_end_date
  def fixed_pay_basis(self) : return self.__fixed_pay_basis
  def float_pay_basis(self) : return self.__float_pay_basis
  def proj_basis(self): return self.__proj_basis
  def fixed_flows(self): return self.__fixed_flows
  def float_flows(self): return self.__float_flows

  def __generate(self):
    start = self.__proj_start_date
    until = self.__proj_end_date
    attributes = self.attributes()

    fixed_period = attributes["fixed-pay-period"]
    fixed_period_duration = attributes["fixed-pay-period-duration"]
    fixed_pay_basis = attributes["fixed-pay-basis"]
    fixed_pay_holiday_centers = attributes["fixed-pay-holiday-centers"]
    fixed_shift_convention = attributes["fixed-shift-convention"]

    float_period = attributes["float-pay-period"]
    float_period_duration = attributes["float-pay-period-duration"]
    float_pay_basis = attributes["float-pay-basis"]
    float_pay_holiday_centers = attributes["float-pay-holiday-centers"]
    float_shift_convention = attributes["float-shift-convention"]

    libor_basis = attributes["index-basis"]
    libor_holiday_centers = attributes["index-holiday-centers"]
    libor_shift_convention = attributes["index-shift-convention"]

    self.__fixed_flows = \
       generate_flows(start
                    , until
                    , period = fixed_period
                    , duration = fixed_period_duration
                    , pay_shift_method = fixed_shift_convention
                    , pay_currency = self.reset_currency()
                    , pay_basis = fixed_pay_basis
                    , pay_holiday_centers = fixed_pay_holiday_centers
                    , accrual_shift_method = fixed_shift_convention
                    , accrual_holiday_centers = fixed_pay_holiday_centers)
    libor_observables = \
       generate_libor_observables(
                      start
                    , until
                    , roll_period = float_period
                    , roll_duration = float_period_duration
                    , reset_period = float_period
                    , reset_duration = float_period_duration
                    , tenor_period = float_period
                    , tenor_duration = float_period_duration
                    , reset_currency = self.reset_currency()
                    , reset_basis = libor_basis
                    , reset_holiday_centres = libor_holiday_centers
                    , reset_shift_method = libor_shift_convention)
    self.__float_flows = \
       generate_flows(start
                    , until
                    , period = float_period
                    , duration = float_period_duration
                    , pay_shift_method = float_shift_convention
                    , pay_currency = self.reset_currency()
                    , pay_basis = float_pay_basis
                    , pay_holiday_centers = float_pay_holiday_centers
                    , accrual_shift_method = float_shift_convention
                    , accrual_holiday_centers = float_pay_holiday_centers
                    , observables = libor_observables)

  def __str__(self):
    s = "%d, " % self.flow_id()
    s += "%d, " % self.reset_id()
    s += "%s, " % self.reset_currency()
    s += "[%s, %s], " % (self.__proj_start_date, self.__proj_end_date)
    return s
\end{verbatim}
Once again for completeness the \verb|swap_rate| class provides a method \verb|forward| 
for determining the value of the swap rate at a particular point in time.
\begin{verbatim}
class swap_rate(observable):
  def forward(self, t, curve):
    fund_pv = 0
    for f in self.__float_flows:
      obs = f.observables()[0]
      proj_start, proj_end, reset_accrual_dcf = \
           (obs.proj_start_date(), obs.proj_end_date(), obs.year_fraction())
      dfs, dfe = \
           curve(int(proj_start - t)/365.0), curve(int(proj_end - t)/365.0)
      libor = (dfs/dfe - 1.0)/reset_accrual_dcf
      pay_date, accrual_dcf = (f.pay_date(), f.year_fraction())
      dfp = curve(int(pay_date - t)/365.0)
      fund_pv += dfp*libor*accrual_dcf

    fixed_pv = 0
    for f in self.__fixed_flows:
      pay_date, accrual_dcf = (f.pay_date(), f.year_fraction())
      dfp = curve(int(pay_date - t)/365.0)
      fixed_pv += dfp*accrual_dcf

    return fund_pv/fixed_pv
\end{verbatim}
Like the \verb|generate_libor_observables()| function of section
\ref{sec:libor}, a function for generating a sequence of swap rate
observables, \verb|generate_swap_observables()|, can be found in the
\verb|ppf.core.generate_observables| module.
\begin{verbatim}
def generate_swap_observables(
   start
 , end
 , attributes
 , spread = 0
 , roll_period = 6
 , roll_duration = ppf.date_time.months
 , tenor_period = 10
 , tenor_duration = ppf.date_time.years
 , reset_currency = "USD"
 , reset_basis = ppf.date_time.basis_act_360
 , reset_holiday_centres = None
 , reset_shift_method = ppf.date_time.modified_following
 , reset_lag = 0
 , *arguments
 , **keywords):
  from ppf.date_time import days
  shift = ppf.date_time.shift

  if reset_lag > 0:
    raise RuntimeError, "index lag expected less or equal to zero"

  day, flow_id, all_observables = 0, 0, []
  while day < end:
      roll_start = start + roll_duration(flow_id*roll_period)
      roll_end = start + roll_duration((flow_id+1)*roll_period)
      reset_id = 0
      proj_roll = roll_start
      proj_start = \
        shift(
            proj_roll
          , reset_shift_method
          , reset_holiday_centres
          )
      proj_end = \
        shift(
            proj_roll+tenor_duration(tenor_period)
          , reset_shift_method, reset_holiday_centres
          )
      reset_date = \
        shift(
            proj_start+days(reset_lag)
          , reset_shift_method, reset_holiday_centres
          )
      all_observables.append(
        swap_rate(
            attributes
          , flow_id
          , reset_id
          , reset_date
          , reset_currency
          , proj_start
          , proj_end
          , fixing(False)
          , spread) )
      flow_id += 1; reset_id += 1; day = roll_end

  return all_observables
\end{verbatim}
The following is an example session demonstrating the generation of a sequence
of swap rate observables.
\begin{verbatim}
    >>> props = {}
    >>> props["fixed-pay-period"] = 1
    >>> props["fixed-pay-period-duration"] = years
    >>> props["fixed-pay-basis"] = basis_act_360
    >>> props["fixed-pay-holiday-centers"] = None
    >>> props["fixed-shift-convention"] = modified_following
    >>> props["float-pay-period"] = 6
    >>> props["float-pay-period-duration"] = months
    >>> props["float-pay-basis"] = basis_act_365
    >>> props["float-pay-holiday-centers"] = None
    >>> props["float-shift-convention"] = modified_following
    >>> props["index-basis"] = basis_act_365
    >>> props["index-holiday-centers"] = None
    >>> props["index-shift-convention"] = modified_following
    >>> observables = generate_swap_observables(
    ...     start  = date(2007, Jun, 29)
    ...   , end  = date(2017, Jun, 29)
    ...   , attributes = props
    ...   , roll_period = 1
    ...   , roll_duration = years
    ...   , tenor_period = 10
    ...   , tenor_duration = years)
    >>> for o in observables: print o
    0, 0, USD, [2007-Jun-29, 2017-Jun-29], 
    1, 0, USD, [2008-Jun-30, 2018-Jun-29], 
    2, 0, USD, [2009-Jun-29, 2019-Jun-28], 
    3, 0, USD, [2010-Jun-29, 2020-Jun-29], 
    4, 0, USD, [2011-Jun-29, 2021-Jun-29], 
    5, 0, USD, [2012-Jun-29, 2022-Jun-29], 
    6, 0, USD, [2013-Jun-28, 2023-Jun-29], 
    7, 0, USD, [2014-Jun-30, 2024-Jun-28], 
    8, 0, USD, [2015-Jun-29, 2025-Jun-30], 
    9, 0, USD, [2016-Jun-29, 2026-Jun-29], 
\end{verbatim}

\section{Flows}\label{sec:flows}
A flow describes a cash flow to be made at some point in time. The actual value 
of the cash flow will depend on a number of things. First of all it will 
depend on the principal or notional of the financial contract. Secondly it 
depends on the currency in which the payment is made. Thirdly, the payment is 
typically accrued over a period of time determined by the accrual start date 
and the accrual end date. The actual formula for calculating the accrued amount is 
controlled by the accrual basis. Fourthly, the date on which the payment is made 
will affect its overall value. Lastly, the payment will depend in some way on 
the value of market observables. For simplicity we treat known coupons, such 
as those on a coupon bearing bond, as observables. In other words a flow will 
always have a least one observable.
  
The class \verb|flow| models the characteristics of a flow and can be
found in the \verb|ppf.core.flow| module. As well as accessors to the
underlying properties of the flow a method is also provided for
calculating the accrual period as a year fraction.
\begin{verbatim}
from ppf.date_time import year_fraction

class flow:
  def __init__(self
             , notional
             , pay_currency
             , accrual_start_date
             , accrual_end_date
             , accrual_basis
             , pay_date
             , observables = None):
    self.__notional = notional
    self.__pay_currency = pay_currency
    self.__accrual_start_date = accrual_start_date
    self.__accrual_end_date = accrual_end_date
    self.__accrual_basis = accrual_basis
    self.__pay_date = pay_date
    self.__observables = observables

  def notional(self): return self.__notional
  def pay_currency(self): return self.__pay_currency
  def accrual_start_date(self): return self.__accrual_start_date
  def accrual_end_date(self): return self.__accrual_end_date
  def pay_date(self): return self.__pay_date
  def observables(self): return self.__observables
  def set_observables(self, observables): self.__observables = observables

  def year_fraction(self):
    return year_fraction(
        self.__accrual_start_date
      , self.__accrual_end_date
      , self.__accrual_basis)

  def __str__(self):
    s = "%f, " % self.__notional
    s += "%s, " % self.__pay_currency
    s += "[%s, %s], " % (self.__accrual_start_date, self.__accrual_end_date)
    s += "%s, " % day_count_basis_strings[self.__accrual_basis]
    s += "%s, " %  self.__pay_date
    if self.__observables <> None:
      for observable in self.__observables:
        s += observable.__str__()
    return s
\end{verbatim}

Analogous to the \verb|generate_libor_observables()| function of
section \ref{sec:libor} and the \verb|generate_swap_observables()| of
section \ref{sec:swap-rate}, the \verb|ppf.core.generate_flows| module
provides the function \verb|generate_flows()| from which a flow
collection can be generated from a high level description.
\begin{verbatim}
import ppf.date_time
from flow import *

def generate_flows(
   start
 , end
 , period = 6
 , duration = ppf.date_time.months
 , notional = 10000000
 , accrual_basis = ppf.date_time.basis_act_360
 , pay_currency = "USD"
 , pay_shift_method  = ppf.date_time.shift_convention.modified_following
 , pay_holiday_centers = None
 , accrual_shift_method  = ppf.date_time.shift_convention.modified_following
 , accrual_holiday_centers = None
 , observables = None
 , *arguments
 , **keywords):

  i, day  = 0, start
  flows = []
  shift = ppf.date_time.shift
  while day < end:
      roll_start = start + duration(i*period)
      roll_end = start + duration((i + 1)*period) 
      accrual_start = shift(
              roll_start
            , accrual_shift_method, accrual_holiday_centers)
      accrual_end = shift(
              roll_end
            , accrual_shift_method, accrual_holiday_centers)
      pay = shift(
              roll_end
            , pay_shift_method, pay_holiday_centers)
      flows.append(
        flow(notional
           , pay_currency
           , accrual_start
           , accrual_end
           , accrual_basis
           , pay)
        )
      day = roll_end
      i += 1
      
  if observables <> None:
    if len(observables) <> len(flows):
      raise RuntimeError, "too few or too many observables"
    for i in range(len(flows)):
      f = flows[i]
      obs = observables[i]
      f.set_observables(obs)
  return flows
\end{verbatim}
Here is an example of the \verb|generate_flows()| function in action:
\begin{verbatim}
>>> flows = generate_flows(
...     start  = date(2007, Jun, 29)
...   , end  = date(2017, Jun, 29)
...   , period = 6
...   , duration = ppf.date_time.months
...   , notional = 1000000
...   , accrual_basis = basis_30360
...   , pay_currency = "JPY"
...   , pay_shift_method = shift_convention.modified_following)
>>> for f in flows:
...  print f
1000000.000000, JPY, [2007-Jun-29, 2007-Dec-31], basis_30360, 2007-Dec-31, 
1000000.000000, JPY, [2007-Dec-31, 2008-Jun-30], basis_30360, 2008-Jun-30, 
1000000.000000, JPY, [2008-Jun-30, 2008-Dec-29], basis_30360, 2008-Dec-29, 
1000000.000000, JPY, [2008-Dec-29, 2009-Jun-29], basis_30360, 2009-Jun-29, 
1000000.000000, JPY, [2009-Jun-29, 2009-Dec-29], basis_30360, 2009-Dec-29, 
1000000.000000, JPY, [2009-Dec-29, 2010-Jun-29], basis_30360, 2010-Jun-29, 
1000000.000000, JPY, [2010-Jun-29, 2010-Dec-29], basis_30360, 2010-Dec-29, 
1000000.000000, JPY, [2010-Dec-29, 2011-Jun-29], basis_30360, 2011-Jun-29, 
1000000.000000, JPY, [2011-Jun-29, 2011-Dec-29], basis_30360, 2011-Dec-29, 
1000000.000000, JPY, [2011-Dec-29, 2012-Jun-29], basis_30360, 2012-Jun-29, 
1000000.000000, JPY, [2012-Jun-29, 2012-Dec-31], basis_30360, 2012-Dec-31, 
1000000.000000, JPY, [2012-Dec-31, 2013-Jun-28], basis_30360, 2013-Jun-28, 
1000000.000000, JPY, [2013-Jun-28, 2013-Dec-30], basis_30360, 2013-Dec-30, 
1000000.000000, JPY, [2013-Dec-30, 2014-Jun-30], basis_30360, 2014-Jun-30, 
1000000.000000, JPY, [2014-Jun-30, 2014-Dec-29], basis_30360, 2014-Dec-29, 
1000000.000000, JPY, [2014-Dec-29, 2015-Jun-29], basis_30360, 2015-Jun-29, 
1000000.000000, JPY, [2015-Jun-29, 2015-Dec-29], basis_30360, 2015-Dec-29, 
1000000.000000, JPY, [2015-Dec-29, 2016-Jun-29], basis_30360, 2016-Jun-29, 
1000000.000000, JPY, [2016-Jun-29, 2016-Dec-29], basis_30360, 2016-Dec-29, 
1000000.000000, JPY, [2016-Dec-29, 2017-Jun-29], basis_30360, 2017-Jun-29, 
\end{verbatim}

\section{Adjuvants}\label{sec:adjuvant-tables}
A financial payoff can depend on constants that vary over time, such
as a gearing or barrier level. The class \verb|adjuvant_table| in
module \verb|ppf.core.adjuvant_table| provides a simple structure for
storing these time-dependent constants. The class is constructed by
taking a list of keys, or equivalently variable names, the dates on
which they apply, and the values. Access to a particular constant at a
specific time is provided via the function call operator.
\begin{verbatim}
class adjuvant_table:
  def __init__(self, keys, dates, values):
    if len(values.shape) <> 2:
      raise RuntimeError, "expected 2d array of values"
    if len(keys) <> values.shape[0] or len(dates) <> values.shape[1]:
      raise RuntimeError, "incorrect size of values array"
    self.__table = {}
    i = 0
    for key in keys:
      elem = {}
      j = 0
      for dt in dates:        
        elem[dt.julian_day()] = values[i][j]
        j += 1
      self.__table[key] = elem
      i += 1

  def __call__(self, key, dt):
    if self.__table.has_key(key):
       elem = self.__table.get(key)
       if elem.has_key(dt.julian_day()):
         return elem.get(dt.julian_day())
       else:
         raise RuntimeError, \
           "unable to find date in adjuvant table"+" dt = "+str(dt)
    else:
       raise RuntimeError, "unable to find key in adjuvant table"

  def __str__(self):
    return self.__table.__str__()
\end{verbatim}
A high level generator for adjuvant tables is provided in the \\
\verb|ppf.core.generate_adjuvant_table| module.
\begin{verbatim}
def generate_adjuvant_table(
   keys
 , tenors
 , values
 , start_date
 , roll_period = 6
 , roll_duration = ppf.date_time.months
 , holiday_centres = None
 , shift_method = ppf.date_time.shift_convention.modified_following
 , *arguments
 , **keywords):
  if len(values.shape) <> 2:
    raise RuntimeError, "expected 2d array of values"
  if len(keys) <> values.shape[0] or len(tenors) <> values.shape[1]:
    raise RuntimeError, "incorrect size of values array"

  from ppf.date_time import days
  shift = ppf.date_time.shift

  day = 0
  dates = []
  indices = []
  cnt = 0
  start = start_date
  for tenor in tenors:
    end = start_date+roll_duration(tenor)
    if end < day:
      raise RuntimeError, "tenors are not monotonically increasing"
    i = 0    
    while day < end:
      roll_start = start+roll_duration(i*roll_period)
      roll_end = start+roll_duration((i+1)*roll_period)
      pay = shift(roll_end, shift_method, holiday_centres)
      day = pay
      dates.append(day)
      indices.append(cnt)
      i += 1
    cnt += 1
    start = end
    
  import numpy
  all_values = numpy.zeros((len(keys), len(dates)))
  for i in range(len(keys)):
    for j in range(len(dates)):
      idx = indices[j]
      all_values[i][j] = values[i][idx]
  return adjuvant_table(keys, dates, all_values)
\end{verbatim}
A sample invocation of the \verb|generate_adjuvant_table()| function is
shown below:
\begin{verbatim}
  >>> from ppf.date_time import *
  >>> from numpy import *
  >>> adjuvants = generate_adjuvant_table(
  ...     keys = ["spread","coupon"]
  ...   , tenors = [12,24,36]
  ...   , values = array([[0.005, 0.006, 0.007], [0.05, 0.06, 0.07]])
  ...   , start_date  = date(2008, May, 1)
  ...   , roll_period = 6
  ...   , shift_method = shift_convention.modified_following)
  >>> print adjuvants
  {'coupon': {2455137: 0.06, 2455683: 0.07, 2454953: 0.05, 
  2455502: 0.07, 2454772: 0.05, 2455318: 0.06}, 
  'spread': {2455137: 0.006, 2455683: 0.007, 
  2454953: 0.005, 2455502: 0.007, 
  2454772: 0.005, 2455318: 0.006}}
\end{verbatim}

\section{Legs}\label{sec:legs}
In essence a leg is simply a collection of flows. However, we also
need to know whether the cash flows they represent are to be paid or
received. The module \verb|ppf.core.pay_recieve| encapsulates this
concept:
\begin{verbatim}
PAY, RECEIVE = (-1, 1)
\end{verbatim}
Furthermore, a leg will also depend on the Python class representing the actual payoff and 
the adjuvant table referenced in the payoff. Examples of concrete payoffs will be discussed in 
the forthcoming chapters. The class \verb|leg| from module \verb|ppf.core.leg| provides an 
implementation of the leg.
\begin{verbatim}
class leg:
  def __init__(self
             , flows
             , pay_or_receive
             , adjuvant_table = None
             , payoff = None):
    self.__flows = flows
    self.__pay_or_receive = pay_or_receive
    self.__adjuvant_table = adjuvant_table
    self.__payoff = payoff

  def flows(self):
    return self.__flows

  def pay_receive(self):
    return self.__pay_or_receive

  def has_adjuvant_table(self):
    return self.__adjuvant_table <> None

  def has_payoff(self):
    return self.__payoff <> None

  def adjuvant_table(self):
    if self.__adjuvant_table == None:
      raise RumtimeError, "Null adjuvant table"
    return self.__adjuvant_table

  def payoff(self):
    if self.__payoff == None:
      raise RumtimeError, "Null payoff"
    return self.__payoff
\end{verbatim}

\section{Exercises}
Many financial structures have exercise decisions embedded in them. An exercise decision or opportunity is 
the right to exercise into or cancel a stream of cash flows at some point in time. 
Typically the writer of the option will require some notification of exercise and so an exercise 
decision is most generally associated with two dates: a notification date and an exercise date. It may also be 
written into the contract that the holder of the option must pay a fee upon exercise. These three data elements
 are bundled up into the class \verb|exercise| in the module \verb|ppf.core.exericse|.
\begin{verbatim}
class exercise:
  def __init__(self
             , notification_date
             , exercise_date
             , fee = None
             , fee_ccy = None):
    self.__notification_date = notification_date
    self.__exercise_date = exercise_date
    self.__fee = fee
    self.__fee_ccy = fee_ccy
    if fee <> None and fee_ccy == None:
      raise RuntimeError, "non-zero fee with no currency"

  def notification_date(self): return self.__notification_date
  def exercise_date(self): return self.__exercise_date
  def fee(self): return self.__fee
  def fee_currency(self): return self.__fee_ccy

  def __str__(self):
    s = "%s, " % self.__notification_date
    s += "%s, " % self.__exercise_date
    if self.__fee <> None:
      s += "%f, " %  self.__fee
      s += "%s, " % self.__fee_ccy
    return s
\end{verbatim}
Exercise opportunities generally offer the holder the right to do one
of two things: enter into a contract or cancel an existing
contract. This classification of exercise opportunities is captured in
the \verb|ppf.core.exercise_type| module.
\begin{verbatim}
class exercise_type:
  callable, cancellable = (1, -1)
\end{verbatim}

Like flows, exercise opportunities frequently come in collections. In
a pattern that is no doubt familiar by now, the
\verb|ppf.core.generate_exercise_table| module offers the function
\verb|generate_exercise_table()| presented below.
\begin{verbatim}
import ppf.date_time
from exercise import *

def generate_exercise_table(
   start
 , end
 , period = 6
 , duration = ppf.date_time.months
 , shift_method  = ppf.date_time.modified_following
 , basis = ppf.date_time.basis_act_360
 , holiday_centers = None
 , fee = None 
 , fee_currency = None
 , *arguments
 , **keywords):
  i, day, exercises = 0, 0, []
  shift = ppf.date_time.shift
  while day < end:
    roll_start = start + duration(i*period)
    roll_end = start + duration((i+1)*period)
    exercise_date = shift(
        roll_start
      , shift_method, holiday_centers)
    # assume no notification lag
    exercises.append(
         exercise(exercise_date, exercise_date, fee, fee_currency))  
    day = exercise_date
    i += 1
  return exercises
\end{verbatim}
Below is an example of the usage of \verb|generate_exercise_table()|:
\begin{verbatim}
   >>> ex_sched = generate_exercise_table(
   ...   start  = date(2007, Jun, 29)
   ... , end  = date(2017, Jun, 29)
   ... , duration = months
   ... , period = 6
   ... , fee = 1000000
   ... , fee_currency = "EUR"
   ... , shift_method = shift_convention.modified_following)
   >>> for ex in ex_sched: print ex
   2007-Jun-29, 2007-Jun-29, 1000000.000000, EUR, 
   2007-Dec-31, 2007-Dec-31, 1000000.000000, EUR, 
   2008-Jun-30, 2008-Jun-30, 1000000.000000, EUR, 
   2008-Dec-29, 2008-Dec-29, 1000000.000000, EUR, 
   2009-Jun-29, 2009-Jun-29, 1000000.000000, EUR, 
   2009-Dec-29, 2009-Dec-29, 1000000.000000, EUR, 
   2010-Jun-29, 2010-Jun-29, 1000000.000000, EUR, 
   2010-Dec-29, 2010-Dec-29, 1000000.000000, EUR, 
   2011-Jun-29, 2011-Jun-29, 1000000.000000, EUR, 
   2011-Dec-29, 2011-Dec-29, 1000000.000000, EUR, 
   2012-Jun-29, 2012-Jun-29, 1000000.000000, EUR, 
   2012-Dec-31, 2012-Dec-31, 1000000.000000, EUR, 
   2013-Jun-28, 2013-Jun-28, 1000000.000000, EUR, 
   2013-Dec-30, 2013-Dec-30, 1000000.000000, EUR, 
   2014-Jun-30, 2014-Jun-30, 1000000.000000, EUR, 
   2014-Dec-29, 2014-Dec-29, 1000000.000000, EUR, 
   2015-Jun-29, 2015-Jun-29, 1000000.000000, EUR, 
   2015-Dec-29, 2015-Dec-29, 1000000.000000, EUR, 
   2016-Jun-29, 2016-Jun-29, 1000000.000000, EUR, 
   2016-Dec-29, 2016-Dec-29, 1000000.000000, EUR, 
   2017-Jun-29, 2017-Jun-29, 1000000.000000, EUR, 
\end{verbatim}

\section{Trades}
A trade is built from a collection of legs and possibly a schedule of
exercise decisions. The class \verb|trade| in module
\verb|ppf.core.trade| encapsulates the concept of a trade.
\begin{verbatim}
class trade:
  def __init__(self, legs, exercise_info=None):
    self.__legs = legs
    self.__exercise_info = exercise_info

  def legs(self):
    return self.__legs

  def exercise_type(self):
    if not self.__exercise_info:
      raise RuntimeError, "missing exercise information"
    return self.__exercise_info[1]

  def exercise_schedule(self):
    if not self.__exercise_info:
      raise RuntimeError, "missing exercise information"
    return self.__exercise_info[0]

  def has_exercise_schedule(self):
    return self.__exercise_schedule != None

\end{verbatim}
The following snippet shows a simple example of how to assemble a trade:
\begin{verbatim}
>>> #semi-annual flows
>>> flows = generate_flows(
...   start  = date(2007, Jun, 29)
...   , end  = date(2017, Jun, 29)
...   , duration = ppf.date_time.months
...   , period = 6
...   , shift_method = shift_convention.modified_following
...   , basis = "ACT/360")
>>> pay_leg = leg(flows, PAY)
>>> receive_leg = leg(flows, RECEIVE)
>>> #1y nc
>>> ex_sched = generate_exercise_table(
...   start = date(2008, Jun, 29)
... , end  = date(2016, Jun, 29)
... , period = 1
... , duration = ppf.date_time.years
... , shift_method = shift_convention.modified_following)
>>> structure = trade([pay_leg, receive_leg], [ex_sched, exercise_type.callable])
>>> print ("callable", "cancellable")[structure.exercise_type() == -1]
callable
\end{verbatim}

\section{Trade Utilities}
It is not uncommon to perform standard operations on the trade
representation. For example the writer of a pricing model may wish to
insist upon the trade being single currency, or that the trade doesn't
contain any exercise stubs. The module \verb|ppf.core.trade_utils| is
the repository for such standard operations. The
\verb|final_important_date| function, detailed below, determines the
last important date of a trade. The last important date is determined
by looping through the legs of a trade and for each flow in the leg
keeping count of the most distant date in the future, be it the flow
pay date or the last important date of the observables attached to the
flow. The end result is the most distant date in the future contained
in the trade representation.
\begin{verbatim}
def final_important_date(trd):
  final_date = date(1900, Jan, 1)
  for l in trd.legs():
    for f in l.flows():
      candidate_date = f.pay_date()
      observables = f.observables()
      if not observables:
        raise RuntimeError, "Missing observables"
      for o in observables:
        if o.last_important_date() > candidate_date:
          candidate_date = o.last_important_date()
      if candidate_date > final_date:
        final_date = candidate_date
  return final_date
\end{verbatim}
Here is a demonstration of the \verb|final_important_date()| function:
\begin{verbatim}
  >>> libor_observables = generate_libor_observables(
  ...     start  = date(2007, Jun, 29)
  ...   , end  = date(2009, Jun, 29)
  ...   , roll_period = 6
  ...   , roll_duration = ppf.date_time.months
  ...   , reset_period = 3
  ...   , reset_duration = ppf.date_time.months
  ...   , reset_currency = "JPY"
  ...   , reset_basis = basis_act_360
  ...   , reset_shift_method = shift_convention.modified_following)
  >>> coupon_observables = generate_fixed_coupon_observables(
  ...     start  = date(2007, Jun, 29)
  ...   , end  = date(2009, Jun, 29)
  ...   , roll_period = 6
  ...   , reset_currency = "JPY"
  ...   , coupon_shift_method = shift_convention.modified_following
  ...   , coupon_rate = 0.045)
  >>> #semi-annual flows
  >>> pay_flows = generate_flows(
  ...   start  = date(2007, Jun, 29)
  ...   , end  = date(2009, Jun, 29)
  ...   , duration = ppf.date_time.months
  ...   , period = 6
  ...   , shift_method = shift_convention.modified_following
  ...   , basis = "30/360"
  ...   , observables = coupon_observables)
  >>> rcv_flows = generate_flows(
  ...   start  = date(2007, Jun, 29)
  ...   , end  = date(2009, Jun, 29)
  ...   , duration = ppf.date_time.months
  ...   , period = 6
  ...   , shift_method = shift_convention.modified_following
  ...   , basis = "A/360"
  ...   , observables = libor_observables)
  >>> pay_leg = leg(pay_flows, PAY)
  >>> receive_leg = leg(rcv_flows, RECEIVE)
  >>> #1y nc
  >>> ex_sched = generate_exercise_table(
  ...   start = date(2008, Jun, 29)
  ... , end  = date(2009, Jun, 29)
  ... , period = 1
  ... , duration = ppf.date_time.years
  ... , shift_method = shift_convention.modified_following)
  >>> structure = trade((pay_leg, receive_leg), (ex_sched, exercise_type.callable))
  >>> print final_important_date(structure)  
  2009-Sep-30
\end{verbatim}

The \verb|enforce_single_currency| function harvests all the
currencies contained in the trade representation, whether they be pay
currencies or observable currencies, and then enforces that the number
of unique currencies must be one.
\begin{verbatim}
def enforce_single_currency(trd):
  ccys = []
  for l in trd.legs():
    for f in l.flows():
      pay_ccy = f.pay_currency()
      observables = f.observables()
      if not observables:
        raise RuntimeError, "Missing observables"
      for o in observables:
        reset_ccy = o.reset_currency()
        if ccys.count(reset_ccy) == 0:
          ccys.append(reset_ccy)
      if ccys.count(pay_ccy) == 0:
        ccys.append(pay_ccy)
  if len(ccys) <> 1:
    raise RuntimeError, "expected one currency"  
  return ccys[0]
\end{verbatim}

Lastly, the \verb|enforce_no_exercise_stubs| function asserts that the
exercise dates, if there are any, must fall within the union of
accrual start dates.
\begin{verbatim}
def enforce_no_exercise_stubs(trd):
  accrual_start_dates = []
  for l in trd.legs():
    for f in l.flows():
      accrual_start_dates.append(f.accrual_start_date())

  if trd.has_exercise_schedule():
    exercises = trd.exercise_schedule()
    for exercise in exercises:
      notification_date = exercise.notification_date()        
      if accrual_start_dates.count(notification_date) == 0:
        raise RuntimeError, "exercise stub encountered"        
\end{verbatim}
All of these utility functions will be used at various stages in the
forthcoming chapters.
