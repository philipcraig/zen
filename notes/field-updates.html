<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <style>
      .code {
      color : #465F91 ;
      background-color: #F5F5F5;
      }
      pre {
      margin-bottom: 4px;
      font-family: monospace;
      background-color: #F5F5F5;
      }
      pre.verbatim, pre.codepre { }
    </style>
    <title>Record Dot Syntax</title>
  </head>
<body>
<h1>Record Dot Syntax</h1>
<p>
The <a href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0282-record-dot-syntax.rst#lexing-and-parsing"><code class="code">RecordDotSyntax</code> proposal</a> defines these hitherto new terms:
<ul>
<li>A field selector is an expression like <code class="code">.a</code> or <code class="code">.a.b</code></li>
<li>A field selection is an expression like <code class="code">r.a</code> or <code class="code">(f x).a.b</code></li>
<li>A field update is an expression like <code class="code">r{a=12}</code> or <code class="code">r{a.b = "foo"}</code> (or like <code class="code">r{a}</code> in so called "punned" field updates)</li>
</ul>
To each there corresponds a new expression syntax: <code class="code">GetField</code>, <code class="code">Projection</code> and <code class="code">RecordDotUpd</code> alternatives of <code class="code">data HsExpr p</code> respectively. Here, for each in turn, implementation notes are presented.
</p>
<h2>Field selectors</h2>
<p>
Field selectors may not be naked. They are parsed as sections. When desugared they are compositions of <code class="code">getField</code> lambda expressions.
<pre><code class="code">aexp2   :: { ECP }
       ...
        | '(' projection ')'
            { ECP $
                let (loc, (anns, fIELDS)) = $2
                     span = combineSrcSpans (combineSrcSpans (getLoc $1) loc) (getLoc $3)
                     expr = mkProjection span (reverse fIELDS)
                     in amms (ecpFromExp' expr) ([mop $1] ++ reverse anns ++ [mcp $3])
            }
</code></pre>
The expression language embodied by <code class="code">data HsExpr p</code> is extended with the following new case into which they parse.
<pre><code class="code">| Projection
       { proj_ext :: XProjection p
       , proj_fIELDS :: [Located FastString]
       , proj_projection :: LHsExpr p -- Equivalent 'getField' term.
       }
</code></pre>
</p>

<h2>Field selections</h2>

<p>
For example, <code class="code">z.x</code> is rendered as <code class="code">getField @"x" z</code>. The production that produces values of this alternative is this.
<pre><code class="code">fexp    :: { ECP }
        -- See Note [Whitespace-sensitive operator parsing] in GHC.Parser.Lexer
        | fexp TIGHT_INFIX_PROJ field
            {% runPV (unECP $1) >>= \ $1 ->
               -- Suppose lhs is an application term e.g. 'f a'
               -- and rhs is '.b'. Usually we want the parse 'f
               -- (a.b)' rather than '(f a).b.'. However, if lhs
               -- is a projection 'r.a' (say) then we want the
               -- parse '(r.a).b'.
               fmap ecpFromExp $ ams (case $1 of
                   L _ (HsApp _ f arg) | not $ isGetField f ->
                     let l = comb2 arg $3 in
                     L (getLoc f `combineSrcSpans` l)
                       (HsApp noExtField f (mkGetField l arg $3))
                   _ -> mkGetField (comb2 $1 $>) $1 $3) [mj AnnDot $2] }
</code></pre>
Field selections are encoded into the following case.
<pre><code class="code">  | GetField
       { gf_ext :: XGetField p
       , gf_expr :: LHsExpr p
       , gf_fIELD :: Located FastString
       , gf_getField :: LHsExpr p -- Equivalent 'getField' term.
       }
</code></pre>
</p>

<h2>Field updates</h2>

<p>In the event a record is being constructed or updated, it's this production that's in play:
<pre><code class="code">aexp1 :: { ECP }
    :  aexp1 '{' fbinds '}'
    {
      getBit RecordDotSyntaxBit >>= \ dot ->
      unECP $1 >>= \ $1 ->
      $3 >>= \ $3 ->
      mkHsRecordPV dot ... $1 (snd $3)
    }
</code></pre>
The rule describes both construction and update. The idea is that the <code class="code">fbinds</code> rule harvests a list of field bindings and the <code class="code">mkHsRecordPV</code> function coalesces them with the constructor or expression to update into a <code class="code">PV (Located b)</code> (<code class="code">b</code> one of expression, pattern, command). The signature of this function is defined by
<pre><code class="code">class b ~ (Body b) GhcPs => DisambECP b where
  mkHsRecordPV ::
    Bool -> -- Is RecordDotSyntax in effect?
    SrcSpan ->
    SrcSpan ->
    Located b ->
    ([Fbind b], Maybe SrcSpan) ->
    PV (Located b)
</code></pre>
Since record dot syntax doesn't particpate in patterns or commands, our focus is restricted to the expression case.
<pre><code class="code">instance DisambECP (HsExpr GhcPs) where
  mkHsRecordPV l lrec a (fbinds, ddLoc) = do
    r <- mkRecConstrOrUpdate a lrec (fbinds, ddLoc)
    checkRecordSyntax (L l r)
</code></pre>
<code class="code">mkRecConstrOrUpdate</code> switches on it's first argument. In the event it's a "qcon", a construction is indicated.
<pre><code class="code">mkRecConstrOrUpdate
        :: LHsExpr GhcPs
        -> SrcSpan
        -> ([Fbind (HsExpr GhcPs)], Maybe SrcSpan)
        -> PV (HsExpr GhcPs)
mkRecConstrOrUpdate (L l (HsVar _ (L _ c))) _ (fs,dd)
  | isRdrDataCon c
  = return (mkRdrRecordCon (L l c) (mk_rec_fields fs dd))
</code></pre>
Since dot notation doesn't participate in record construction we have no further interest in it, it's the update case we care about.
</p>
<p>
 So what is a field binding? Before we got to it, what we've been writing as <code class="code">[Fbind (HsExpr GhcPs)]</code> was <code class="code">[LHsRecField GhcPs (LHsExpr GhcPs)]</code> that is, a list of updates, each update modeled by a record field. Then we had,
<pre><code class="code">mkRecConstrOrUpdate exp _ (fs,dd)
  | Just dd_loc <- dd = addFatalError $ Error ErrDotsInRecordUpdate [] dd_loc
  | otherwise = return (mkRdrRecordUpd exp (map (fmap mk_rec_upd_field) fs))

mkRdrRecordUpd :: LHsExpr GhcPs -> [LHsRecUpdField GhcPs] -> HsExpr GhcPs
mkRdrRecordUpd exp flds
  = RecordUpd { rupd_ext  = noExtField
              , rupd_expr = exp
              , rupd_flds = flds }
</code></pre>
The list of fbinds is bundled together with the record expression being updated into a <code class="code">RecordUpd</code> syntax node for later renaming, typing and desugaring. As we'll see, with dot syntax enabled, generally what we compute in its place here now is a <code class="code">setField</code> expression.
</p>
<p>Record dot syntax adds new syntax for a field binding. Here are all the cases.
<pre><code class="code">fbind   :: { forall b. DisambECP b => PV (Fbind b) }
        : qvar '=' texp
        | qvar
        | field TIGHT_INFIX_PROJ fieldToUpdate '=' texp
        | field TIGHT_INFIX_PROJ fieldToUpdate
</code></pre>
The last two productions are new and cannot be represented by <code class="code">LHsRecField GhcPs (LHsExpr GhcPs)</code>s. How do we represent them? As Haskell functions. To be concrete suppose the update "foo.bar.baz.quux = 43", then this is represented
<pre><code class="code">\a -> setField@"foo" (a) (setField@"bar" (getField @"foo" (a))(setField@"baz" (getField @"bar" (getField @"foo" (a)))(setField@"quux" (getField @"baz" (getField @"bar" (getField @"foo" (a))))(43))))
</code></pre>
Such a function takes a record expression argument to a <code class="code">setField</code> encoded expression of the result. <code class="code">Fbind b</code> accomodates these two alternatives.
<pre><code class="code">data Fbind b = Fbind (LHsRecField GhcPs (Located b))
             | Pbind (LHsProjUpdate GhcPs (Located b))
</code></pre>
The first two productions compute cases of <code class="code">Fbind (LHsRecField GhcPs (Located b))</code>, the other two, <code class="code">Pbind (LHsProjUpdate GhcPs (Located b))</code>. Here's how we define <code class="code">LHsProjUpdate p arg</code> and some associated type aliases we'll see in use later.
<pre><code class="code">data ProjUpdate' p arg =
  ProjUpdate {
      pb_fIELDS :: [Located FastString]
    , pb_arg :: arg -- Field's new value e.g. 42
    , pb_func :: arg -> arg
    }
type ProjUpdate p arg = ProjUpdate' p arg
type LHsProjUpdate p arg = Located (ProjUpdate p arg)
type RecUpdProj p = ProjUpdate' p (LHsExpr p)
type LHsRecUpdProj p = Located (RecUpdProj p)
</code></pre>
</p>
<p>
It's easy enough to convert an <code class="code">LHsRecField GhcPs (LHsExpr GhcPs)</code> to an <code class="code">LHsProjUpdate GhcPs (LHsExpr GhcPs)</code> by <code class="code">recUpdFieldToProjUpdate (fmap mk_rec_upd_field f)</code> where <code class="code">f</code> is such a field and
<code class="code">recUpdFieldToProjUpdate :: LHsRecUpdField GhcPs -> LHsRecUpdProj GhcPs</code> is the function to consult. With this we can process <code class="code">Fbind (HsExpr GhcPs)</code> of both cases uniformly as <code class="code">LHsRecUpdProj GhcPs</code> values.
<pre><code class="code">toProjUpdates :: [Fbind (HsExpr GhcPs)] -> [LHsRecUpdProj GhcPs]
toProjUpdates = map (\case { Pbind p -> p
                           ; Fbind f -> recUpdFieldToProjUpdate (fmap mk_rec_upd_field f)
                    })
</code></pre>
Finally we arrive at the new <code class="code">data HsExpr p</code> constructor syntax.
<pre><code class="code">-- We call this RecordDotUpd in sympathy with RecordUpd.
  -- e.g. a{foo.bar.baz=1, quux} = RecordDotUpd {
  --   rdupd_ext=noExtField, rdupd_expr=a, rdupd_updates=[...], rdupd_setField=setField@"quux" (setField@"foo"...a... 1) quux
  -- },
  | RecordDotUpd
    { rdupd_ext :: XRecordDotUpd
    , rdupd_expr :: LHsExpr GhcPs
    , rdupd_updates :: [LHsProjUpdate GhcPs (LHsExpr GhcPs)]
    , rdupd_setField :: LHsExpr GhcPs -- Equivalent 'setField' term.
    }
</code></pre>
The trick to producing them is to substitute <code class="code">mkRdrRecordUpd'</code> for <code class="code">mkRdrRecordUpd</code>.
</p>
</body>
</html>
