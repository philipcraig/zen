<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <style>
      .keyword { font-weight : bold ; color : Red }
      .keywordsign { color : #C04600 }
      .comment { color : Green }
      .constructor { color : Blue }
      .type { color : #5C6585 }
      .string { color : Maroon }
      .warning { color : Red ; font-weight : bold }
      .info { margin-left : 3em; margin-right: 3em }
      .param_info { margin-top: 4px; margin-left : 3em; margin-right : 3em }
      .code {
      color : #465F91 ; 
      background-color: #F5F5F5;
      }
      pre {
      margin-bottom: 4px;
      font-family: monospace; 
      background-color: #F5F5F5;
      }
      pre.verbatim, pre.codepre { }
    </style>
    <title>Shortest Path</title>
  </head>
  <body>
    <p>This article assumes familiarity with Dijkstra's shortest path algorithm. For a refresher, see [1]. The code assumes <code>open Core</code> is in effect and is online <a href="https://github.com/shayne-fletcher/zen/tree/master/ocaml/dijkstra">here</a>.
    </p>
    <p>The first part of the program organizes our thoughts about what we are setting out to compute. The signature summarizes the notion (for our purposes) of a graph definition in modular form. A module implementing this signature defines a type <code>vertex_t</code> for vertices, a type <code>t</code> for graphs and type <code>extern_t</code> : a representation of a <code>t</code> for interaction between an implemening module and its "outside world".
<pre>module type Graph_sig = sig
  type vertex_t [@@deriving sexp]
  type t [@@deriving sexp]
  type extern_t

  type load_error = [ `Duplicate_vertex of vertex_t ] [@@deriving sexp]
  exception Load_error of load_error [@@deriving sexp]

  val of_adjacency : extern_t -> [ `Ok of t | `Load_error of load_error ]
  val to_adjacency : t -> extern_t

  module Dijkstra : sig
    type state

    type error = [
      | `Relax of vertex_t
    ] [@@deriving sexp]
    exception Error of error [@@deriving sexp]

    val dijkstra : vertex_t -> t -> [ `Ok of state | `Error of error ]
    val d : state -> (vertex_t * float) list
    val shortest_paths : state -> (vertex_t * vertex_t list) list
  end

end
</pre>
A realization of <code>Graph_sig</code> provides "conversion" functions <code>of_adjacency</code>/<code>to_adjacency</code> between the types <code>extern_t</code> and <code>t</code> and nests a module <code>Dijkstra</code>. The signature of the sub-module <code>Dijkstra</code> requires concrete modules provide a type <code>state</code> and an implementation of Dijkstra's algorithm in terms of the function signature <code>val dijkstra : vertex_t -> t -> [ `Ok of state | `Error of error ]</code>.
    </p>
    <p>For reusability, the strategy for implementing graphs will be generic programming via functors over modules implementing s vertex type.</p>
    <p>An implementation of the module type <code>GRAPH</code> defines a module type <code>VERT</code> which is required to provide a comparable type <code>t</code>. It further defines a module type <code>S</code> that is exactly module type <code>Graph_sig</code> above. Lastly, modules of type <code>GRAPH</code> provide a functor <code>Make</code> that maps any module of type <code>VERT</code> to new module of type <code>S</code> fixing <code>extern_t</code> to an adjacency list representation in terms of the native OCaml type <code>'a list</code> and <code>float</code> to represent weights on edges.
<pre>
module type GRAPH = sig
  module type VERT = sig
    type t[@@deriving sexp]
    include Comparable.S with type t := t
  end

  module type S = sig
    include Graph_sig
  end

  module Make : functor (V : VERT) ->
    S with type vertex_t = V.t
       and type extern_t = (V.t * (V.t * float) list) list
end
</pre>
The two module types <code>Graph_sig</code> and <code>Graph</code> together provide the specification for the program. <code>module Graph</code> in the next section implements this specification.
    </p>
    <p>Implementation of module <code>Graph</code> is in outline this.
<pre>
module Graph : GRAPH = struct
  module type VERT = sig
    type t[@@deriving sexp]
    include Comparable.S with type t := t
  end

  module type S = sig
    include Graph_sig
  end

  module Make : functor (V : VERT) ->
    S with type vertex_t = V.t
       and type extern_t = (V.t * (V.t * float) list) list
    =

    functor (V : VERT) -> struct
       ...
    end
end
</pre>
As per the requirements of <code>GRAPH</code> the module types <code>VERT</code> and <code>S</code> are provided as is the functor <code>Make</code>. It is the code that is ellided by the <code>...</code> above in the definition of <code>Make</code> that is now the focus.
    </p>
    <p>Modules produced by applications of <code>Make</code> satisfy <code>S</code>. This requires suitable definitions of types <code>vertext_t</code>, <code>t</code> and <code>extern_t</code>. The modules <code>Map</code> and <code>Set</code> are available due to modules of type <code>VERT</code> being comparable in their type <code>t</code>.
<pre>      module Map = V.Map
      module Set = V.Set

      type vertex_t = V.t [@@deriving sexp]
      type t = (vertex_t * float) list Map.t [@@deriving sexp]
      type extern_t = (vertex_t * (vertex_t * float) list) list
      type load_error = [ `Duplicate_vertex of vertex_t ] [@@deriving sexp]
      exception Load_error of load_error [@@deriving sexp]
</pre>
    </p>
    <p>While the external representation <code>extern_t</code> of graphs is chosen to be an adjacency list representation in terms of association lists, the internal representation <code>t</code> is a vertex map of adjacency lists providing logarithmic loookup complexity. The conversion functions between the two representations "come for free" via module <code>Map</code>.

<pre>      let to_adjacency g = Map.to_alist g

      let of_adjacency_exn l =  match Map.of_alist l with
        | `Ok t -> t
        | `Duplicate_key c -> raise (Load_error (`Duplicate_vertex c))

      let of_adjacency l =
        try
          `Ok (of_adjacency_exn l)
        with
        | Load_error err -> `Load_error err
</pre>
    </p>
<p>At this point the "scaffolding" for Dijkstra's algorithm, that part of <code>GRAPH</code> dealing with the representation of graphs is implemented.</p>
<p>The interpretation of Dijkstra's algorithm we adopt is functional : the idea is we loop over vertices relaxing their edges until all shortest paths are known. What we know on any recursive iteration of the loop is a current "state" (of the computation) and each iteration produces a new state. This next definition is the formal definition of <code>type state</code>.
<pre>      module Dijkstra = struct

        type state = {
          src    :                  vertex_t
        ; g      :                         t
        ; d      :               float Map.t
        ; pred   :            vertex_t Map.t
        ; s      :                     Set.t
        ; v_s    : (vertex_t * float) Heap.t
        }
</pre>
The fields of this record are:
<ul><li><code>src : vertex_t</code>, the source vertex;</li>
<li><code>g : t</code>, <i>G</i> the graph;</li>
<li><code>d : float Map.t</code>, <i>d</i> the shortest path weight estimates;</li>
<li><code>pre : vertex_t Map.t</code>, <i>&pi;</i> the predecessor relation;</li>
<li><code>s : Set.t</code>, the set <i>S</i> of nodes for which the lower bound shortest path weight is known;</li>
<li><code>v_s : (vertex_t * float) Heap.t</code>, <i>V - {S}, </i> , the set of nodes of <code>g</code> for which the lower bound of the shortest path weight is not yet known ordered on their estimates.</li>
</ul>
<p>Function invocation <code>init src g</code> compuates an initial state for the graph <code>g</code> containing the source node <code>src</code>. In the initial state, <code>d</code> is everywhere <i>&infin;</i> except for <code>src</code> which is <i>0</i>. Set <i>S</i> (i.e. <code>s</code>) and the predecessor relation <i>&pi;</i> (i.e. <code>pred</code>) are empty and the set <i>V - {S}</i> (i.e. <code>v_s</code>) contains all nodes.
<pre>        let init src g =
          let init x = match V.equal src x with
            | true -> 0.0 | false -> Float.infinity in
          let d = List.fold (Map.keys g) ~init:Map.empty
              ~f:(fun acc x -> Map.set acc ~key:x ~data:(init x)) in
          {
            src
          ; g
          ; s = Set.empty
          ; d
          ; pred = Map.empty
          ; v_s = Heap.of_list (Map.to_alist d)
                ~cmp:(fun (_, e1) (_, e2) -> Float.compare e1 e2)
          }
</pre>
</p>
<p>Relaxing an edge <i>(u, v)</i> with weight <i>w (u, v)</i> tests whether the shortest path to <i>v</i> so far can be improved by going through <i>u</i> and if so, updating <i>d (v)</i> and <i>&pi; (v)</i> accordingly.
<pre>        type error = [
          | `Relax of vertex_t
        ] [@@deriving sexp]
        exception Error of error [@@deriving sexp]

        let relax state (u, v, w) =
          let {d; pred; v_s; _} = state in
          let dv = match Map.find d v with
            | Some dv -> dv
            | None -> raise (Error (`Relax v)) in
          let du = match Map.find d u with
            | Some du -> du
            | None -> raise (Error (`Relax u)) in
          if dv > du +. w then
            let dv = du +. w in
            (match Heap.find_elt v_s ~f:(fun (n, _) -> V.equal n v) with
            | Some tok -> ignore (Heap.update v_s tok (v, dv))
            | None -> raise (Error (`Relax v))
            );
            { state with
              d = Map.change d v
                  ~f:(function
                      | Some _ -> Some dv
                      | None -> raise (Error (`Relax v))
                    )
            ; pred = Map.set (Map.remove pred v) ~key:v ~data:u
            }
          else state
</pre>
Here, relaxation can result in a linear heap update operation. A better implementation might seek to avoid that.
</p>
<p>One iteration of the body of the loop of Dijkstra's algorithm consists of the node in <i>V - {S}</i> with the least shortest path weight estimate being moved to <i>S</i> and its edges relaxed.
<pre>        let dijkstra_exn src g =
          let rec loop ({s; v_s; _} as state) =
            match Heap.is_empty v_s with
            | true -> state
            | false ->
              let u = fst (Heap.pop_exn v_s) in
              loop (
                List.fold (Map.find_exn g u)
                  ~init:{ state with s = Set.add s u }
                  ~f:(fun state (v, w) -> relax state (u, v, w))
              )
          in loop (init src g)

        let dijkstra src g =
          try
            `Ok (dijkstra_exn src g)
          with
          | Error err -> `Error err
</pre>
</p>
    <p>The shortest path estimates contained by a value of <code>state</code> is given by the projection <code>d</code>.
<pre>        let d state = Map.to_alist (state.d)
</pre>
</p>
<p>The shortest paths themselves are easily computed as,
<pre>
        let path state n =
          let rec loop acc x =
            (match V.equal x state.src with
            | true -> x :: acc
            | false -> loop (x :: acc) (Map.find_exn state.pred x)
            ) in
          loop [] n

        let shortest_paths state =
          List.map (Map.keys state.g) ~f:(fun n -> (n, path state n))
      end
    end
</pre> which completes the implementation of <code>Make</code>.
<p>The following program produces a concrete instance of the shortest path problem (with some evaluation output from the top-level).
<pre>module G : Graph.S with
  type vertex_t = char and type extern_t = (char * (char * float) list) list
  =
  Graph.Make (Char)

let g : G.t =
  match G.of_adjacency
          [ 's', ['u',  3.0; 'x', 5.0]
          ; 'u', ['x',  2.0; 'v', 6.0]
          ; 'x', ['v',  4.0; 'y', 6.0; 'u', 1.0]
          ; 'v', ['y',  2.0]
          ; 'y', ['v',  7.0]
          ]
  with
  | `Ok g -> g
  | `Load_error e -> failwiths "Graph load error : %s" e G.sexp_of_load_error
;;
let s = match (G.Dijkstra.dijkstra 's' g) with
  | `Ok s -> s
  | `Error e -> failwiths "Error : %s" e G.Dijkstra.sexp_of_error

;; G.Dijkstra.d s
- : (char * float) list =
[('s', 0.); ('u', 3.); ('v', 9.); ('x', 5.); ('y', 11.)]

;; G.Dijkstra.shortest_paths s
- : (char * char list) list =
[('s', ['s']); ('u', ['s'; 'u']); ('v', ['s'; 'u'; 'v']); ('x', ['s'; 'x']);
 ('y', ['s'; 'x'; 'y'])]
</pre>
</p>
</p>
    <p>
    <hr/>
    <p>
      References:<br/>
      [1] "Introduction to Algorithms" Section 24.3:Dijkstra's alorithm -- Cormen et. al. (Second ed.) 2001.<br/>
    </p>
  </body>
</html>
