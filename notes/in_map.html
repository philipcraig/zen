<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <title></title>
  </head>
  <body>
    <p>
      Here are two well known "classic" functions over polymorphic
      lists.
    </p>
    <p>
      <code>map f l</code> computes a new list from <code>l</code>
      by applying <code>f</code> to each of its elements.
      <pre class="prettyprint ml">
        let rec map (f : &alpha; &rarr; &beta;) : &alpha; list &rarr; &beta; list = function
        | [] &rarr; []
        | h :: t &rarr; f h :: map f t
        ;;
      </pre>
    </p>

    <p><code>mem x l</code> returns <code>true</code> is <code>x</code>
      is an element of <code>l</code> and returns <code>false</code> if it
      is not.
      <pre class="prettyprint ml">
        let rec mem (a : &alpha;) : &alpha; list &rarr; bool  = function
        | [] &rarr; false
        | x :: l &rarr; a = x || mem a l
        ;;
      </pre>
    </p>
    <p>
      If <code>y</code> is an element of the list obtained by
      mapping <code>f</code> over <code>l</code> then there must be an
      element <code>x</code> in <code>l</code> such that <code>f x =
        y</code>. Conversely, if there exists an <code>x</code>
      in <code>l</code> such that <code>y = f x</code>,
      then <code>y</code> must be a member of the list obtained by
      mapping <code>f</code> over <code>l</code>.
   </p>
    <p>
      We attempt a proof of correctness of the given definitions with
      respect to this property.
    </p>

    <b>Lemma</b> <code>mem_map_iff</code>:
    <pre>
    &forall; (f : &alpha; &rarr; &beta;) (l : &alpha; list) (y : &beta;),
        mem y (map f l) &iff; &exist;(x : &alpha;), f x = y &and; mem x l.
    </pre>
    <b>Proof:</b><br/>
    <ul>

      <li>We first treat the forward implication
        <pre>
    &forall; (f : &alpha; &rarr; &beta;) (l : &alpha; list) (y : &beta;), 
      mem y (map f l) &Implies; &exist;(x : &alpha;), f x = y &and; mem x l
        </pre>
        and proceed by induction on <code>l</code>.
        <br/>
        <br/>

        <ul>
          <li><code>l = []</code>:
            <ul>
              <li>Show <code>mem y (map f []) &Implies; &exist;(x : &alpha;), f x = y &and; mem x []</code>.</li>
              <li><code>mem y (map f []) &equiv; False</code>.</li>
              <li>Proof follows <i>(ex falso quodlibet)</i>.</li>
            </ul>
            <br/>
          </li> <!-- l is empty -->

        <li><code>l</code> has form <code>x' :: l</code> (use <code>l</code> now to refer to the tail):
            <ul>
              <li>Assume the induction hypothesis:
                <ul><li><code>mem y (map f l) &Implies; &exist;x, f x = y &and; mem x l</code>.</li></ul></li>
              <li>We are required to show for an arbitrary <code>(x' : &alpha;)</code>:
                <ul><li><code>mem y (map f (x' :: l)) &Implies; &exist;(x : &alpha;), f x = y &and; mem x (x' :: l)</code>.</li></ul>
              </li>
              <li>By simplification, we can rewrite the above to:
                <ul><li><code>f x' = y &or; mem y (map f l) &Implies; &exist;(x : &alpha;), f x = y &and; (x' = x &or; mem x l).</code></li></ul>
              </li>
              <li>We assume then an <code>(x' : &alpha;)</code> and a <code>(y : &beta;)</code> such
                that:
                <ol>
                  <li><code>f x' = y &or; mem y (map f l)</code>.</li>
                  <li><code>mem y (map f l) &Implies; &exist;(x : &alpha;), f x = y &and; mem x l</code>.</li>
                </ol>
              </li>
              <li>Show <code>&exist;(x : &alpha;), f x = y &and; (x' = x &or; mem x l).</code>
                <ul>
                  <li>First consider <code>f x' = y</code> in (1).
                    <ul>
                      <li>Take <code>x = x'</code> in the goal.</li>
                      <li>Then by (1) <code>f x = y &and; x = x'</code>.</li>
                      <li>So <code>x'</code> is a witness.</li>
                    </ul>
                  </li>
                  <li>Now consider <code>mem y (map f l)</code> in (1).
                    <ul>
                      <li><code>&exist;(x<sup>*</sup> : &alpha;), f x<sup>*</sup> = y &and; mem x<sup>*</sup> l</code> by (2).</li>
                      <li>Take <code>x = x<sup>*</sup></code> in the goal.</li>
                      <li>By the above <code>f x<sup>*</sup> = y &and; mem x<sup>*</sup> l</code></li>
                      <li>So <code>x<sup>*</sup></code> is a witness</code>.</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li> <!-- l is non-empty -->
        </ul>
        <br/></br>
      </li><!-- Forward implication -->

      <li>
      We now work on the reverse implication. We want to show that
      <pre>
    &forall; (f : &alpha; &rarr; &beta;) (l : &alpha; list) (y : &beta;),
       &exist;(x : &alpha;), f x = y &and; mem x l &Implies; mem y (map f l)
      </pre>
      and proceed by induction on <code>l</code>.
      <br/><br/>
      <ul>
        <li><code>l = []:</code>
        <ul>
          <li>Assume <code>x</code>, <code>y</code> with <code>f x = y &and; mem x []</code>.</li>
          <li>Show <code>mem y (map f [])</code>:</li>
           <ul>
             <li><code>mem x [] &equiv; false</code>.</li>
             <li>Proof follows <i>(ex falso quodlibet)</i>.</li>
           </ul>
        </ul>
        </li><!-- l = [] -->

        <li><code>l</code> has form <code>x' :: l</code> (use <code>l</code> now to refer to the tail):
          <ul>
            <li>Assume the induction hypothesis:
            <ul><li><code>&exist;(x : &alpha;), f x = y &and; mem x l &Implies; mem y (map f l)</code>.</li></ul>
            </li>
            <li>We are required to show for an arbitrary <code>(x' : &alpha;)</code>:
              <ul><li><code>&exist; (x : &alpha;), f x = y &and; mem x (x' :: l) &Implies; mem y (map f (x' :: l))</code></li></ul>
            </li>
            <li>By simplification, we can rewrite the above to:
              <ul><li><code>&exist; (x : &alpha;), f x = y &and; x = x' &or; mem x l &Implies; f x' = y &or; mem y (map f l)</code>.</li></ul>
            </li>
            <li>Assume the goal and induction hypotheses:
              <ul>
                <li>There is <code>(x : &alpha;)</code> and <code>(y : &beta;)</code> such that:
                  <ol>
                    <li><code>f x = y &and; (x = x' &or; mem x l)</code></li>
                    <li><code>f x = y &and; mem x l &Implies; mem y (map f l)</code></li>
                  </ol>
                </li>
              </ul>
            </li>
            <li>Show <code>f x' = y &or; mem y (map f l)</code>.
              <ul>
                <li>Assume <code>x = x'</code> in (1) and show <code>f x' = y</code>:
                  <ul>
                   <li>Since, <code>f x = y</code> is given by (1.), <code>f x' = y</code>.</li>
                  </ul>
                </li>
                <li>Assume <code>mem x l</code> in (1) and show <code>mem y (map f l)</code>:
                  <ul> 
                    <li>Rewrite <code>mem y (map f l)</code> via (2) to <code>f x = y &and; mem x l</code>.</li>
                    <li><code>f x = y</code> by (1) so <code>mem y (map f l)</code>.</li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li><!-- l is non-empty -->
      </ul>
      </li><!-- Reverse implication -->
    </ul>
&#8718;
    <hr/>
    <p>
    References:<br/>
    <a href="https://www.cis.upenn.edu/~bcpierce/sf/current/index.html">"Sofware Foundations"</a> -- Pierce et. al.
    </p>
  </body>
</html>
