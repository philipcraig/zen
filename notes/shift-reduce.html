<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <title>Shifting, reducing and resolving conflicts</title>
  </head>
  <body>
  <h2>The <code>ocamlyacc</code> Parser Algorithm</h2>
  <p>As a parser reads tokens, it pushes them onto a stack along with their semantic values. The stack is called the <i>parser stack</i>. Pushing a token is tradionally called <i>shifting</i>.
  </p>
  <p>
  For example, suppose an infix calculator has read <code>'1 + 5 *'</code>, with a <code>'3'</code> to come. The stack will have 4 elements, one for each token that was shifted.
  </p>
  <p>
  But the stack does not always have an element for each token read. When the last <i>n</i> tokens and groupings shifted match the components of a grammar rule, they can be combined according to that rule. This is called <i>reduction</i>. Those tokens and groupings are replaced on the stack by a single grouping whose symbol is the result (left-hand-side) of that rule. Running that rule's action is part of the process of reduction, because this is what computes the semantic value of the resulting grouping.
  </p>
  <p>For example, if the infix calculator's parser stack contains this:
  <pre>1 + 5 * 3</pre>
  and the next input token is a newline character, then the last three elements can be reduced to <code>15</code> via the rule:
  <pre>expr : expr * expr;</pre>
  Then the stack contains just these three elements:
  <pre>1 + 15</pre>
  At this point, another reduction can be made, resulting in the single value <code>16</code>. Then the newline token can be shifted.
  </p>
  <p>The parser tries, by shifts and reductions, to reduce the entire input down to a single grouping whose symbol is the grammar's start-symbol.
  </p>
  <p>This kind of parser is known in the literature as a bottom-up parser.
  </p>

  <h2>Look-Ahead Tokens</h2>
  <p>The parser does <i>not</i> always reduce immediately as soon as the last <i>n</i> tokens and groupings match a rule. This is because such a simple strategy is inadequate to handle most languages. Instead, when a reduction is possible, the parser sometimes "looks ahead" at the next token in order to decide what to do.
  </p>
  <p>When a token is read, is is not immediately shifted; first it becomes the <i>look-ahead token</i>, which is not on the stack. Now the parser can do one or more reductions of tokens and groupings on the stack, while the look-ahead token remains off to the side. When no more reductions should take place, the look-ahead token is shifted onto the stack. This does not mean that all possible reductions have been done; depending on the token type of the look-ahead token, some rules may choose to delay their application.
  </p>
  <p>Here is a simple case where look-ahead is needed. These three rules define expressions which contain binary addition operators and postfix unary factorial operators ('<code>!</code>'), and allow parentheses for grouping:
  <pre>expr: 
  | term '+' expr
  | term
  ;

term:
  | '(' expr ')'
  | term '!'
  | NUMBER
  ;</pre>
  Suppose that the tokens '<code>1 + 2</code>' have been read and shifted; what should be done? If the following token is '<code>)</code>', then the first three tokens must be reduced to form an <code>expr</code>. This is the only valid course, because shifting the '<code>)</code>' would produce a sequence of sybmols <code>term ')'</code>, and no rule allows this.
  </p>
  <p>If the following token is '<code>!</code>', then it must be shifted immediately so that '<code>2 !</code>' can be reduced to make a <code>term</code>. If instead the parser were to reduce before shifting, '<code>1 + 2</code>' would become an <code>expr</code>. It would then be impossible to shift the '<code>!</code>' because doing so would produce on the stack the sequence of symbols <code>expr '!'</code>. No rule allows that sequence.
  </p>

  <h2>Shift/Reduce Conflicts</h2>
  <p>Suppose we are parsing a language which has if-then and if-then-else statements, with a pair of rules like this:
  <pre>if_stmt:
  | IF expr THEN stmt
  | IF expr THEN stmt ELSE stmt
  ;</pre>
  Here we assume <code>IF</code>, <code>THEN</code> and <code>ELSE</code> are teminal symbols for specific keyword tokens.
  </p>
  <p>When the <code>ELSE</code> token is read and becomes the look-ahead token, the contents of the stack (assuming the input is valid) are just right for reduction by the first rule. But it is also legitimate to shift the <code>ELSE</code>, because that would lead to eventual reduction by the second rule.
  </p>
  <p>This situation, where either a shift or a reduction would be valid, is called a <i>shift/reduce</i> conflict. <code>ocamlyacc</code> is designed to resolve these conflicts by choosing to shift, unless otherwise directed by  operator precedence declarations. To see the reason for this, let's contrast it with the other alternative.
  </p>
  <p>Since the parser prefers to shift the <code>ELSE</code>, the result is to attach the else-clause of the innermost if-statement, making these two inputs equivalent:
  <pre>if x then if y then win (); else lose;
if x then do; if y then win (); else lose; end</pre>
  But if the parser chose to reduce when possible rather than shift, the result would be to attach the else-clause to the outermost if-statement, making these two inputs equivalent:
  <pre>if x then if y then win (); else lose;
if x then do; if y then win (); end; else lose;</pre>
  The conflict exists because the grammar as written is ambiguous: either parsing of the simple nested if-statement is legitimate. The established convention is that these ambiguities are resolved by attaching the else-clause to the innermost if-statement; this is what is accomplished by choosing to shift rather than reduce. (It would ideally be cleaner to write an unambiguous grammar, but that is very hard to do in this case.) This particular ambiguity was first encountered in the specifications of Algol60 and is called the "dangling else" ambiguity.
  </p>
  <p>The definition of <code>if_stmt</code> above is solely to blame for the conflict, but the conflict does not actually appear without additional rules. here is a complete input file that actually manifests the conflict:
  <pre>%token IF THEN ELSE variable

%start stmt
%type&lt;unit&gt; stmt
%%
stmt:
 | expr                             {()}
 | if_stmt                          {()}
 ;

if_stmt:
  | IF expr THEN stmt               {()}
  | IF expr THEN stmt ELSE stmt     {()}
  ;

expr:
  | variable                        {()}
  ;</pre>
  Examining the output from <code>ocamlyacc</code> we observe the following:
  <pre>10: shift/reduce conflict (shift 11, reduce 3) on ELSE
state 10
	if_stmt : IF expr THEN stmt .  (3)
	if_stmt : IF expr THEN stmt . ELSE stmt  (4)

	ELSE  shift 11
	$end  reduce 3</pre>
  </p>
  The output explains that state 10 has a conflict on the <code>ELSE</code>. The <code>shift 11</code> means that one action is to shift the <code>ELSE</code> and go to state 11 the other option is to reduce using rule 3 where rule 3 is with respect to the list at the beginning of the output file i.e.:
  <pre>3  if_stmt : IF expr THEN stmt</pre>

  <h2>Operator precedence</h2>
  <p>Another situation where shift/reduce conflicts appear is in arithmetic expressions. Here shifting is not always the preferred resolution; the <code>ocamlyacc</code> declarations for operator precedence allow you to specify when to shift and when to reduce.
  </p>

  <h3>When precedence is needed</h3>
  <p>Consider the following ambiguous grammar fragment (ambiguous because the input '<code>1 - 2 * 3</code>' can be parsed in two different ways):
  <pre>expr:
  | expr '-' expr
  | expr '*' expr
  | expr '&lt;' expr
  | expr '(' expr ')'
  ...
  ;</pre>
  Suppose the parser has seen the tokens '<code>1</code>', '<code>-</code>' and '<code>2</code>'; should it reduce them via the rule for the subtraction operator? It depends on the next token. Of course, if the next token is '<code>)</code>', we must reduce; shifting is invalid because no single rule can reduce the token sequence '<code>- 2 )</code>' or anything starting with that. But if the next token is '<code>*</code>' or '<code><</code>', we have a choice : either shifting or reduction would allow the parse to complete, but with different results.
  </p>
  <p>To decide which one the parser must do, we must consider the results. If the next operator token <i>op</i> is shifted, then it must be reduced first in order to permit another opportunity to reduce the sum. The result is (in effect), '<code>1 - (2 op 3)</code>'. On the other hand, if the subtraction is reduced before shifting <i>op</i>, the result is '<code>(1 - 2) op 3</code>'. Clearly, then, the choice of shift or reduce should depend on the relative precedence of the operators '<code>-</code>' and <i>op</i> : '<code>*</code>' should be shifted first, but not '<code>&lt;</code>'.
  </p>
  <p>What about input such as '<code>1 - 2 - 5</code>'; should this be '<code>(1 - 2) - 5</code>' or should it be '<code>1 - (2 - 5)</code>'? For most operators we prefer the former, which is called <i>"left association"</i>. The latter alternative, <i>"right association"</i> is a matter of whether the parser chooses to shift or reduce when the stack contains '<code>1 - 2</code>' and the look-ahead token is <code>'-'</code> : shifting makes right-associativity.
  </p>

  <h3>Specifying Operator Precedence</h3>
  <p><code>ocamlyacc</code> allows you to specify these choices with the operator precedence declarations <code>%left</code> and <code>%right</code>. Each such declaration contains a list of tokens, which are operators whose precedence and associativity is being declared. The <code>%left</code> declaration makes all those operators left-associative and the <code>%right</code> declaration makes them right associative. A third alternative is <code>%nonassoc</code>, which declares that it is a syntax error to find the same operator twice "in a row".
  </p>
  <p>The relative precedence of the different operators is controlled by the order in which they are declared. The first <code>%left</code> or <code>%right</code> declaration in the file declares the operators whose precedence is lowest, the next such declaration declares the operators whose precedence is a little higher, and so on.
  </p>

  <h3>Precedence Examples</h3>
  <p>In our example, we would want the following declarations:
  <pre>%left '<'
%left '-'
%left '*'</pre>
  In a more complete example, which supports other operators as well, we would declare them in groups of equal precedence. For example, '<code>+</code>' is declared with '<code>-</code>':
  <pre>%left '<' '>' '=' NE LE GE
%left '+' '-'
%left '*' '/'</pre>
  </p>

  <h3>How Precedence Works</h3>
  <p>The first effect of the precedence declarations is to assign precedence levels to the terminal symbols declared. The second effect is to assign precedence levels to certain rules: each rule get its precedence from the last terminal symbol mentioned in the components. (You can also specify explicitly the precedence of a rule. See the next section.)
  </p>
  <p>Finally, the resolution of conflicts works by comparing the precedence of the rule being considered with that of the look-ahead token. If the token's precedence is higher, the choice is to shift. If the rule's precedence is higher, the choice is to reduce. If they have equal precedence, the choice is made based on the associativity of that precedence level. the verbose output file made by '<code>-v</code>' says how each conflict was resolved.
  </p>
  <p>Not all rules and not all tokens have precedence. If either the rule or the look-ahead token has no precedence, then the default is to shift.
  </p>

  <h3>Context-Dependent Precedence</h3>
  <p>Often the precedence of an operator depends on the context. This sounds outlandish at first, but it is really very common. For example, a minus sign typically has a very high precedence as a unary operator, and a somewhat lower precedence (lower than multiplication) as a binary operator.
  </p>
  <p>The <code>ocamlyacc</code> precedence declarations, <code>%left</code>, <code>%right</code> and <code>%nonassoc</code>, can only be used once for a given token; so a token has only one precedence declared in this way. For context-dependent precedence, you need to use an additional mechanism:the <code>%pre</code> modifier for rules.
  </p>
  <p>The <code>%prec</code> modifier declares the precedence of a particular rule by specifying a terminal symbol whose precedence should be used for that rule. It's not necessary for that symbol to appear otherwise in that rule. The modifier's syntax is:
  <pre>%prec <i>terminal-symbol</i></pre>
and it is written after the components of the rule. Its effect is to assign the rule the precedence of <i>terminal-symbol</i>, overriding the precedence that would be deduced for it in the ordinary way. The altered rule precedence then affects how conflicts involving that rule are resolved (see section Operator Precedence).
  </p>
  <p>Here is how <code>%prec</code> solves the problem of unary minus. First, declare a precedence of a fictious terminal symbol named <code>UMINUS</code>. There are no tokens of this type, but the symbol serves to stand for its precedence:
  <pre>...
%left '+' '-'
%left '*'
%left UMINUS</pre>
  Now the precedence of <code>UMINUS</code> can be used in specific rules:
  <pre>exp: ...
  | exp '-' exp
  ...
  | '-' exp %prec UMINUS</pre>
  </p>

  <h3>A Complete Example : Desk calculator</h3>
  <p>This program reads arithmetic expressions on standard input, one per line, and prints their values. Here is the grammar definition:
  <pre>/*File parser.mly*/
%token <int> T_int
%token T_plus T_minus T_star T_slash
%token T_lparen T_rparen
%token T_eol

%left T_plus T_minus
%left T_star T_slash
%nonassoc prec_uminus

%start main
%type &lt;int&gt; main
%%
main:
 | expr T_eol                      { $1 }
 ;

expr:
 | T_int                           { $1 }
 | T_lparen expr T_rparen          { $2 }
 | expr T_plus expr           { $1 + $3 }
 | expr T_minus expr          { $1 - $3 }
 | expr T_star expr           { $1 * $3 }
 | expr T_slash expr          { $1 / $3 }
 | T_minus expr %prec prec_uminus {- $2 }
 ;</pre>
  Here is the definition for the corresponding lexer:
  <pre>(*File lexer.mll*)
{
  open Parser
  exception Eof
}
rule token = parse
  | [' ' '\t']                     { token lexbuf }
  | ['\n']                                { T_eol }
  | ['0'-'9']+ as lxm { T_int (int_of_string lxm) }
  | '+'                                  { T_plus }
  | '-'                                 { T_minus }
  | '*'                                  { T_star }
  | '/'                                 { T_slash }
  | '('                                { T_lparen }
  | ')'                                { T_rparen }
  | eof                               { raise Eof }</pre>
  Here is the main program that combines the parser with the lexer:
  <pre>(*File calc.ml*)
let _ =
  try
    let lexbuf = Lexing.from_channel stdin in
    while true do
      let result = Parser.main Lexer.token lexbuf in
      print_int result; print_newline (); flush stdout
    done
  with
  | Lexer.Eof -> exit 0</pre>
  To compile everything, execute:
  <pre>ocamlyacc parser.mly
ocamllex lexer.mll
ocamlc -c parser.mli
ocamlc -c lexer.ml
ocamlc -c lexer.ml
ocamlc -c parser.ml
ocamlc -c calc.ml
ocamlc -o calc lexer.cmo parser.cmo calc.cmo</pre>
  </p>
  <hr/>
  <p>References:<br/>
   [1] "BISON : The YACC-Compatible Parser Generator" -- Donelly & Stallman, 1995<br/>
   [2] <a href="http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual026.html">Chapter 12 Lexer and parser generators (ocamllex, ocamlyacc)</a> (The OCaml system release 4.04) -- Leroy et.al.
  </p>
  </body>
</html>
