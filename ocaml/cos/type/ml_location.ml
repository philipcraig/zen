(*A value of type [Lexing.position] describes a point in a source
  file.

  {[
    type position={
      pos_fname : string;
      pos_lnum : int;
      pos_bol : int;
      pos_cnum : int
    } 
  ]}

  [pos_fname] is the file name; [pos_lnum] is the line number;
  [pos_bol] is the offset of the beginning of the line (number of
  characters between the beginning of the lexbuf and the beginning of
  the line); [pos_cnum] is the offset of the position (number of
  characters between the beginning of the lexbuf and the
  position). The difference between [pos_cnum] and [pos_bol] is the
  character offset within the line (i.e. the column number, assuming
  each character is one column wide).
*)

open Lexing

type t = { 
  loc_start : position; 
  loc_end : position;
  loc_ghost : bool
}
(*Ghost expressions and patterns do not appear explicitly in the
  source file. 

  Every grammar rule that generates an element with a location must
  make at most one non-ghost element, the topmost one.

  To determine if your location must be marked 'ghost':

  - A location corresponds to a range of characters in the source
    file;
  - If the location contains a piece of code that is syntactically
    valid and corresponds to an AST node, then the location must be
    real;
  - In all other cases, it must be ghost.
*)

let in_file (name : string) : t =
  let loc : position = {
    pos_fname = name; (*The name of the file*)
    pos_lnum = 1; (*The line number of the position*)
    pos_bol = 0; (*Offset from the beginning of the lexbuf of the line*)
    pos_cnum = -1; (*Offset of the position from the beginning of the lexbuf*)
  } in
  { loc_start = loc; loc_end = loc; loc_ghost = true }

let none : t = in_file "_none_"

(*[Lexing.lexbuf] is the type of lexer buffers. A lexer buffer is the
  argument passed to the scanning functions defined by the generated
  scanners. The lexer buffer holds the current state of the scanner,
  plus a function to refill the buffer from the input.

  {[
    type lexbuf = {
      refill_buff : lexbuf -> unit;
      mutable lex_buffer : bytes;
      mutable lex_buffer_len : int;
      mutable lex_abs_pos : int;
      mutable lex_start_pos : int;
      mutable lex_curr_pos : int;
      mutable lex_last_pos : int;
      mutable lex_last_action : int;
      mutable lex_eof_reached : bool;
      mutable lex_mem : int array;
      mutable lex_start_p : position;
      mutable lex_curr_p : position;
    }
  ]}

  At each token, the lexing engine will copy [lex_curr_p] to
  [lex_start_p], then change the [pos_cnum] field of [lex_curr_p] by
  updating it with the number of characters read since the start of
  the [lexbuf]. The other fields are left unchanged by the lexing
  engine. In order to keep them accurate, they must be initialized
  before the first use of the lexbuf, and updated by the relevant
  lexer actions.
*)

let init (lexbuf : Lexing.lexbuf) (fname : string) : unit =
  let open Lexing in
  lexbuf.lex_curr_p <- {
    pos_fname = fname;
    pos_lnum = 1;
    pos_bol = 0;
    pos_cnum = 0;
  }

let curr (lexbuf : Lexing.lexbuf) : t = 
  let open Lexing in {
    loc_start = lexbuf.lex_start_p;
    loc_end = lexbuf.lex_curr_p;
    loc_ghost = false;
  }

(*[Parsing] is the run-time library for parsers generated by
  ocamlyacc

  The functions [symbol_start] and [symbol_end] are to be called in
  the action part of a grammar rule (only). They return the offset of
  the string that matches the left-hand-side of the rule :
  [symbol_start ()] returns the offset of the first character;
  [symbol_end ()] returns the offset after the last character. The
  first character in a file is at offset 0.

  [symbol_start_pos ()] and [symbol_end_pos ()] are like [symbol_start
  ()] and [symbol_end ()] but return [Lexing.position] instead of an
  offset.
*)

let symbol_rloc () : t = {
  loc_start = Parsing.symbol_start_pos ();
  loc_end = Parsing.symbol_end_pos ();
  loc_ghost = false
}

let symbol_gloc () : t =  { 
  loc_start = Parsing.symbol_start_pos ();
  loc_end = Parsing.symbol_end_pos ();
  loc_ghost = true
}

(*The [Parsing] functions [rhs_start] and [rhs_end] are the same as
  [symbol_start] and [symbol_end] but return the offset of the string
  matching the [n]th item on the right-hand-side of the rule, where
  [n] is the integer parameter to [rhs_start] and [rhs_end]. [n] is 1
  for the leftmost item. [rhs_start_pos] and [rhs_end_pos] return a
  position instead of an offset.*)

let rhs_loc n = {
  loc_start = Parsing.rhs_start_pos n;
  loc_end = Parsing.rhs_end_pos n;
  loc_ghost = false;
}

type 'a loc = { 
  txt : 'a;
  loc : t; 
}

let mkloc (txt : 'a) (loc : t) : 'a loc = { txt ; loc }
let mknoloc (txt : 'a) : 'a loc = mkloc txt none

open Format

type error =
  {
    loc: t;
    msg: string;
    sub: error list;
  }

let pp_ksprintf ?before k fmt =
  let buf = Buffer.create 64 in
  let ppf = Format.formatter_of_buffer buf in
  begin match before with
    | None -> ()
    | Some f -> f ppf
  end;
  kfprintf
    (fun _ ->
      pp_print_flush ppf ();
      let msg = Buffer.contents buf in
      k msg)
    ppf fmt

let print_filename ppf file =
  fprintf ppf "%s" file

let (msg_file, msg_line, msg_chars, msg_to, msg_colon) =
    ("File \"", 
     "\", line ", 
     ", characters ", 
     "-", 
     ":")

(*Return file, line, char from the given position*)
let get_pos_info pos =
  (pos.pos_fname, pos.pos_lnum, pos.pos_cnum - pos.pos_bol)

let print_loc ppf loc =
  let (file, line, startchar) = get_pos_info loc.loc_start in
  let endchar = loc.loc_end.pos_cnum - loc.loc_start.pos_cnum + startchar in
  if file = "//toplevel//" then
    fprintf ppf "Characters %i-%i"
      loc.loc_start.pos_cnum loc.loc_end.pos_cnum
  else begin
    fprintf ppf "%s@{<loc>%a%s%i" msg_file print_filename file msg_line line;
    if startchar >= 0 then
      fprintf ppf "%s%i%s%i" msg_chars startchar msg_to endchar;
    fprintf ppf "@}"
  end

let print ppf loc =
  fprintf ppf "@{<loc>%a@}%s@." print_loc loc msg_colon

let error_prefix = "Error"
let warning_prefix = "Warning"

let print_error_prefix ppf () =
  fprintf ppf "@{<error>%s@}:" error_prefix;
  ()

let errorf_prefixed ?(loc=none) ?(sub=[]) fmt =
  pp_ksprintf
    ~before:(fun ppf -> fprintf ppf "%a " print_error_prefix ())
    (fun msg -> {loc; msg; sub})
    fmt

let error_of_exn : (exn -> error option) list ref = ref []

let register_error_of_exn f = error_of_exn := f :: !error_of_exn

let error_of_printer loc print x =
  errorf_prefixed ~loc "%a@?" print x

let error_of_exn exn =
  let rec loop = function
    | [] -> None
    | f :: rest ->
      match f exn with
      | Some _ as r -> r
      | None -> loop rest
  in
  loop !error_of_exn

let rec default_error_reporter ppf ({loc; msg; sub}) =
  print ppf loc;
  Format.pp_print_string ppf msg;
  List.iter (Format.fprintf ppf "@\n@[<2>%a@]" default_error_reporter) sub

let error_reporter = ref default_error_reporter

let num_loc_lines = ref 0 (* number of lines already printed after input *)

let print_updating_num_loc_lines ppf f arg =
  let out_functions = pp_get_formatter_out_functions ppf () in
  let out_string str start len =
    let rec count i c =
      if i = start + len then c
      else if String.get str i = '\n' then count (succ i) (succ c)
      else count (succ i) c in
    num_loc_lines := !num_loc_lines + count start 0;
    out_functions.out_string str start len in
  pp_set_formatter_out_functions ppf 
    {out_functions with out_string} ;
  f ppf arg ;
  pp_print_flush ppf ();
  pp_set_formatter_out_functions ppf out_functions

let report_error ppf err =
  print_updating_num_loc_lines ppf !error_reporter err

let rec report_exception_rec n ppf exn =
  try match error_of_exn exn with
  | Some err -> fprintf ppf "@[%a@]@." report_error err
  | None -> raise exn
  with exn when n > 0 ->
    report_exception_rec (n - 1) ppf exn

let report_exception ppf exn = report_exception_rec 5 ppf exn
