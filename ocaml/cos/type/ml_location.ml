(*A value of type [Lexing.position] describes a point in a source
  file.

  {[
    type position={
      pos_fname : string;
      pos_lnum : int;
      pos_bol : int;
      pos_cnum : int
    } 
  ]}

  [pos_fname] is the file name; [pos_lnum] is the line number;
  [pos_bol] is the offset of the beginning of the line (number of
  characters between the beginning of the lexbuf and the beginning of
  the line); [pos_cnum] is the offset of the position (number of
  characters between the beginning of the lexbuf and the
  position). The difference between [pos_cnum] and [pos_bol] is the
  character offset within the line (i.e. the column number, assuming
  each character is one column wide).
*)

type t = { 
  loc_start : Lexing.position; 
  loc_end : Lexing.position;
  loc_ghost : bool
}
(*Ghost expressions and patterns do not appear explicitly in the
  source file. 

  Every grammar rule that generates an element with a location must
  make at most one non-ghost element, the topmost one.

  To determine if your location must be marked 'ghost':

  - A location corresponds to a range of characters in the source
    file;
  - If the location contains a piece of code that is syntactically
    valid and corresponds to an AST node, then the location must be
    real;
  - In all other cases, it must be ghost.
*)

let in_file (name : string) : t =
  let open Lexing in
  let loc : position = {
    pos_fname = name; (*The name of the file*)
    pos_lnum = 1; (*The line number of the position*)
    pos_bol = 0; (*Offset from the beginning of the lexbuf of the line*)
    pos_cnum = -1; (*Offset of the position from the beginning of the lexbuf*)
  } in
  { loc_start = loc; loc_end = loc; loc_ghost = true }

let none : t = in_file "_none_"

(*[Lexing.lexbuf] is the type of lexer buffers. A lexer buffer is the
  argument passed to the scanning functions defined by the generated
  scanners. The lexer buffer holds the current state of the scanner,
  plus a function to refill the buffer from the input.

  {[
    type lexbuf = {
      refill_buff : lexbuf -> unit;
      mutable lex_buffer : bytes;
      mutable lex_buffer_len : int;
      mutable lex_abs_pos : int;
      mutable lex_start_pos : int;
      mutable lex_curr_pos : int;
      mutable lex_last_pos : int;
      mutable lex_last_action : int;
      mutable lex_eof_reached : bool;
      mutable lex_mem : int array;
      mutable lex_start_p : position;
      mutable lex_curr_p : position;
    }
  ]}

  At each token, the lexing engine will copy [lex_curr_p] to
  [lex_start_p], then change the [pos_cnum] field of [lex_curr_p] by
  updating it with the number of characters read since the start of
  the [lexbuf]. The other fields are left unchanged by the lexing
  engine. In order to keep them accurate, they must be initialized
  before the first use of the lexbuf, and updated by the relevant
  lexer actions.
*)

let init (lexbuf : Lexing.lexbuf) (fname : string) : unit =
  let open Lexing in
  lexbuf.lex_curr_p <- {
    pos_fname = fname;
    pos_lnum = 1;
    pos_bol = 0;
    pos_cnum = 0;
  }

let curr (lexbuf : Lexing.lexbuf) : t = 
  let open Lexing in {
    loc_start = lexbuf.lex_start_p;
    loc_end = lexbuf.lex_curr_p;
    loc_ghost = false;
  }

(*[Parsing] is the run-time library for parsers generated by
  ocamlyacc

  The functions [symbol_start] and [symbol_end] are to be called in
  the action part of a grammar rule (only). They return the offset of
  the string that matches the left-hand-side of the rule :
  [symbol_start ()] returns the offset of the first character;
  [symbol_end ()] returns the offset after the last character. The
  first character in a file is at offset 0.

  [symbol_start_pos ()] and [symbol_end_pos ()] are like [symbol_start
  ()] and [symbol_end ()] but return [Lexing.position] instead of an
  offset.
*)

let symbol_rloc () : t = {
  loc_start = Parsing.symbol_start_pos ();
  loc_end = Parsing.symbol_end_pos ();
  loc_ghost = false
}

let symbol_gloc () : t =  { 
  loc_start = Parsing.symbol_start_pos ();
  loc_end = Parsing.symbol_end_pos ();
  loc_ghost = false
}

(*The [Parsing] functions [rhs_start] and [rhs_end] are the same as
  [symbol_start] and [symbol_end] but return the offset of the string
  matching the [n]th item on the right-hand-side of the rule, where [n]
  is the integer parameter to [rhs_start] and [rhs_end]. [n] is 1 for
  the leftmost item*)

let rhs_loc n = {
  loc_start = Parsing.rhs_start_pos n;
  loc_end = Parsing.rhs_end_pos n;
  loc_ghost = false;
}

type 'a loc = { 
  txt : 'a;
  loc : t; 
}

let mkloc (txt : 'a) (loc : t) : 'a loc = { txt ; loc }
let mknoloc (txt : 'a) : 'a loc = mkloc txt none
