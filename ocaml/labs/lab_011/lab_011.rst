
html,
    h1 {
    font-family: Helvetica, Geneva, Arial,  SunSans-Regular, sans-serif 
    }
    body {
    font-family:Verdana, Geneva, sans-serif; 
   }
Weekly Exercises : #11
2015-03-28 by 
Difficulty level :
Medium/Hard
Problem :
Breadth-first graph traversal algorithm.
R&D X-asset Risk/Pricing > Week #011 > lab011-example.png

The graph above has this OCaml adjacency list representation:
let g : G.t =
  G.of_adjacency
    ['r', ['v'; 's']      ;
     'v', ['r']           ;
     's', ['r'; 'w']      ;
     'w', ['x'; 't']      ;
     't', ['w'; 'x'; 'u'] ;
     'x', ['w'; 't'; 'y'] ;
     'u', ['t'; 'y']      ;
     'y', ['x'; 'u']      ;
    ]
That is, where
module type Graph_sig = sig
  type node
  type t
  type colors = White | Gray | Black
  type 'a state


  val of_adjacency : (node * node list) list -> t
  val breadth_first_fold : t -> node -> 'b -> ('b -> node -> 'b) -> 'b state
  val discovery_times : 'a state -> (node * int) list
  val colors : 'a state -> (node * colors) list
  val data : 'a state -> 'a
end
 
module type GRAPH = sig
  module type Ord=sig 
    type t val compare : t -> t -> int
  end

  module type S = sig
    include Graph_sig
  end


  module Make : functor (N : Ord) -> S with type node = N.t
end
For example, in the top-level we can derive these facts about this graph:
# module G : Graph.S with type node = Char.t = Graph.Make (Char);;
module G :
  sig
    type node = Char.t
    type t
    type colors = White | Gray | Black
    type 'a state
    val of_adjacency : (node * node list) list -> t
    val breadth_first_fold : t -> node -> 'b -> ('b -> node -> 'b) -> 'b state
    val discovery_times : 'a state -> (node * int) list
    val colors : 'a state -> (node * colors) list
    val data : 'a state -> 'a
  end
# let g : G.t =
  G.of_adjacency
    ['r', ['v'; 's']      ;
     'v', ['r']           ;
     's', ['r'; 'w']      ;
     'w', ['x'; 't']      ;
     't', ['w'; 'x'; 'u'] ;
     'x', ['w'; 't'; 'y'] ;
     'u', ['t'; 'y']      ;
     'y', ['x'; 'u']      ;
    ];;
                    val g : G.t = <abstr>
# let s : (G.node list) G.state= G.breadth_first_fold g 's' [] (fun acc x -> x :: acc);;
val s : G.node list G.state = <abstr>
# let times : (G.node * int) list = G.discovery_times s;;
val times : (G.node * int) list = [('r', 1); ('s', 0); ('t', 2); ('u', 3); ('v', 2); ('w', 1); ('x', 2); ('y', 3)]
# let colors : (G.node * G.colors) list = G.colors s;;
val colors : (G.node * G.colors) list =
  [('r', G.Black); ('s', G.Black); ('t', G.Black); ('u', G.Black); ('v', G.Black); ('w', G.Black); ('x', G.Black); ('y', G.Black)]
# let l : G.node list = List.rev (G.data s);;
val l : G.node list = ['s'; 'r'; 'w'; 'v'; 'x'; 't'; 'y'; 'u']
Implement a module satisfying this interface. Hint : Use the OCaml Queue module.

Solutions:

(*Eugene Perederey*)

module type Graph_sig = 
  sig
    type node  
    type t
    type colors = White | Gray | Black  
    val of_adjacency : (node * node list) list -> t  
    type 'a state    
    val discovery_times : 'a state -> (node * int) list
    val colors : 'a state -> (node * colors) list
    val data : 'a state -> 'a
    val breadth_first_fold : t -> node -> 'b -> ('b -> node -> 'b) -> 'b state
  end  
  
module type GRAPH = 
  sig
    module type Ord = 
      sig
        type t 
        val compare : t -> t -> int
      end
    
    module type S = 
      sig
        include Graph_sig
      end

    module Make : functor (N : Ord) -> S with type node = N.t
  end

module Graph : GRAPH =
  struct
    module type Ord = 
      sig
        type t 
        val compare : t -> t -> int
      end
    
    module type S = 
      sig
        include Graph_sig
      end

    module Make(N : Ord) : S with type node = N.t =
      struct
        type node = N.t
        module NodeMap = Map.Make(N)
        type t = (node list) NodeMap.t  (* adjacency lists *)
        type colors = White | Gray | Black  
        let of_adjacency = 
          List.fold_left (fun m (n, ns) -> NodeMap.add n ns m) NodeMap.empty 

        type 'a state = {
            mutable d: int NodeMap.t;
            mutable c: colors NodeMap.t;
            mutable acc: 'a;
          }    

        let discovery_times s = NodeMap.bindings s.d

        let colors s = NodeMap.bindings s.c          

        let data s = s.acc

        (* assume the graph is connected. 
           Otherwise traverse only the connected component containing the starting node *)
        let breadth_first_fold graph n acc f = 
          let q = Queue.create () in
          Queue.push (n, 0) q;
          let state = {
              d=NodeMap.empty;
              c=NodeMap.singleton n Gray;
              acc=acc} in
          while not (Queue.is_empty q)
          do
            let (n, t) = Queue.pop q in
            state.acc <- f state.acc n;
            (* color it black, save the discovery time *)
            state.c <- NodeMap.add n Black state.c;
            state.d <- NodeMap.add n t state.d;
            let white_neighbors = List.filter (fun n' -> not (NodeMap.mem n' state.c)) (NodeMap.find n graph) in
            (* enqueue them, color them gray *)
            List.iter (fun n' -> Queue.push (n', t + 1) q) white_neighbors;
            state.c <- List.fold_left (fun c n -> NodeMap.add n Gray c) state.c white_neighbors;
          done;
          state

      end
  end

module G = Graph.Make(Char)

let g : G.t =  
  G.of_adjacency   
    ['r', ['v'; 's']      ;     
     'v', ['r']           ;     
     's', ['r'; 'w']      ;     
     'w', ['x'; 't']      ;     
     't', ['w'; 'x'; 'u'] ;     
     'x', ['w'; 't'; 'y'] ;     
     'u', ['t'; 'y']      ;     
     'y', ['x'; 'u']      ;    ]


let s : (G.node list) G.state= G.breadth_first_fold g 's' [] (fun acc x -> x :: acc);;

let times : (G.node * int) list = G.discovery_times s;;

let colors : (G.node * G.colors) list = G.colors s;;

let l : G.node list = List.rev (G.data s);;
