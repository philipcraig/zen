 html,     h1 {     font-family: Helvetica, Geneva, Arial,  SunSans-Regular, sans-serif      }     body {     font-family:Verdana, Geneva, sans-serif;     } Weekly Exercises : #19 2016-01-05 by  Difficulty level : Medium Problem : This is very cool. In this exercise we consider a data structure with side effects yet client code may use it as if it were a purely applicative data structure! This is thus an example of an imperative data structure whose side effects are safely hidden behind a persistent interface (and not a mention of the ©M© word in what follows I promise (smile)).  A persistent array is a data structure providing the same operations as a usual array, namely the manipulation of elements indexed from 0 to n - 1, with low cost access and update operations, but where the update operation returns a new persistent array and leaves the previous one unchanged. A good motivation for persistent arrays is in the implementation of backtracking algorithms. Here is a reasonable signature for basic polymorphic persistent arrays: module type Persistent_array_sig = sig    type   t   (*the array type*)    val init : int -> (int ->  ) ->   t   val make : int ->   ->   t    val get :   t -> int ->     val set :   t -> int ->   ->   t    val string_of_array : (  -> string) ->   t -> string    end Now of course it©s easy to define a purely functional array module that implements this signature... module Functional_array : Persistent_array_sig = struct   type   t =   array    let init = Array.init   let make = Array.make   let get = Array.get    let set (t :   t) (i : int) (v :  ) :   t =     let t© = Array.copy t in     a©.(i) <- v;     a©   end ... but it©s slow because each call to set results in copying into a new array (ouch!).  An efficient solution to the problem of persistent arrays due to H. Baker1 has been known for some time (he used the idea to implement closures in a LISP runtime). The main idea is this. Introduce the following mutually recursive data types:   type   t =   data ref   and   data = Arr of   array | Diff of int *   *   t The type   t is the type of persistent arrays. It is a reference on a value of type   data which is: either an immediate value Arr a with an array a, or an indirection Diff (i, v, t) standing for a persistent array which is identical to the persistent array t everywhere except at index i where it contains v.  OK, well there it is - implement the given signature utilising the definition of the persistent array type given above!  To get you started, here are some hints. First, the init function is obvious :    let init (n : int) (f : int ->  ) :   t =  ref (Arr (Array.init n f)) The function get is straightforward. Either the persistent array is an immediate array or, we need to consider the indirection an possibly recursively access another persistent array. The subtlety is all in the set function . The idea is to keep the efficiency of a usual array on the very last version of the persistent array, while possibly decreasing the efficiency of previous versions. When updating the persistent array t, there are two possible cases either t is a reference to a value of shape Arr a; in that case we replace t with an indirection (which is possible since it is a reference and not a value of type   data) modify the array a in place and return a new reference pointing to Arr a or t is already an indirection, that is pointing to a Diff node; then we simply create and return a new indirection.  When you©ve got the basic idea implemented, for extra fun you might want to read about improvements that can be made, the most significant of which is a procedure that Baker calls rerooting in the paper that motivated this exercise available here (spoiler alert : the paper provides code).  [1] Henry G. Baker. Shallow binding in Lisp 1.5. Commun. ACM, 21(7):565±569, 1978. Solutions : This implementation is credited to Sen Han. module type Persistent_array_sig = sig   type   t    val init : int -> (int ->  ) ->   t   val make : int ->   ->   t   val get :   t -> int ->     val set :   t -> int ->   ->   t   val string_of_array : (   -> string ) ->   t -> string  end  module Functional_array : Persistent_array_sig = struct   type   t =   data ref   and   data = Arr of   array | Diff of int *   *   t    let init (n : int) (f : int ->  ) :   t= ref (Arr(Array.init n f));;    let make (n : int) (v :  ) : (  t)     = (init n (fun x -> v));;    let get (farray :   t) (pos : int) :   =     let rec aux func_arr index =       match !func_arr with       | Arr(oarray) -> oarray.(index);       | Diff(i, v, f_arr) ->           if i = index then v           else (aux f_arr index)     in     aux farray pos;;    let set (farray :   t) (i : int) (v :  ) :   t =     match !farray with     | Arr(oarray) ->         let temp = oarray.(i) in         oarray.(i) <- v;         let new_ref = ref(Arr(oarray)) in         farray := Diff(i, temp, new_ref);         new_ref;     | Diff(p, value, f_arr) -> ref (Diff(i, v, farray));;     let flatten ( arr : (  t) ) :   array =     let rec aux ( arr : (  t) ) :   array =       match !arr with       | Arr(real_array) -> (Array.copy real_array)       | Diff(i, v, f_arr) ->           let oarray = (aux f_arr) in           oarray.(i) <- v;           oarray     in     (aux arr);;   let string_of_array (f :   -> string) (arr :   t) : string =     String.concat "" (Array.to_list (Array.map f (flatten arr) ));; end ;;  open Functional_array ;; let a0 = init 7 (fun _ -> 0) ;; let a1 = set a0 1 7 ;; let a2 = set a1 2 8 ;; let a3 = set a1 2 9 ;; string_of_array string_of_int a0 ;; string_of_array string_of_int a1 ;; string_of_array string_of_int a2 ;; string_of_array string_of_int a3;; Execution of this program in the top-level produces # - : string = "0000000" # - : string = "0700000" # - : string = "0780000" # - : string = "0790000" Neat! Got all the properties we expected. Next, here©s an implementation of this program in C++14 using the Pretty Good Sum Type library: #include <gtest/gtest.h> #include "sum_type.hpp" #include <memory> #include <vector> #include <iterator> #include <algorithm> #include <iostream> #include <sstream>  //A persistent array is a data structure providing the same operations //as a usual array, namely the manipulation of elements indexed from //¡0¡ to ¡n - 1¡, with low cost access and update operations, but //where the update operation returns a new persistent array and leaves //the previous one unchanged. //The approach taken here due to Baker[1] follows the recitation in //Conchon/Filliatre[2]. For the sake of this being tutorial in nature, //we stop short of providing the version that employs "rerooting" (not //that it©s at all hard to implement). //What©s interesting about this data structure is that from the point //of view of the client, it is purely applicative. However, the //implementation is imperative in nature and the persistence illusory! //One thing to watch out for here is the massive use of side effects //rendering this program seriously multi-thread unfriendly. //[1] Henry G. Baker. Shallow binding in Lisp 1.5. Commun. ACM, //21(7):565-569, 1978. // //[2]"A Persistent Union-Find Data Structure Sylvain Conchon, //Jean-Chrisophe Filliatre //"http://www.lri.fr/~filliatr/ftp/publis/puf-wml07.ps  namespace {   namespace detail {   using namespace pgs;    //The goal here is an efficient solution to the problem of   //persistent arrays. The basic idea is to use a usual array for   //the last version of the persistent array and indirections for   //pervious versions.   template <class T> struct array_data; //fwd. decl.    //¡peristent_array<T>¡ is the type of persistent arrays. It is a   //reference on a value of type ¡array_data<T>¡ which inidicates   //its nature (being a sum of two cases)   template <class T> using persistent_array = std::shared_ptr<array_data<T>>;    //Case 1 : An immediate value of type ¡array_t<T>¡ containing a   //member ¡data¡ of type ¡std::vector<T>¡   template <class T>   struct array_t {     std::vector <T> data;//array data     array_t (int n, T const& val) : data{n, val}     {}     array_t (std::vector<T>&& data) : data {data}     {}   };      //Case 2 : An indirection of type ¡diff_t<T>¡ value effectively a   //product ¡(i, v, t)¡ standing for a persistent array which is   //identical to the persistent array ¡t¡ everywhere except at index   //¡i¡ where it contains ¡v¡   template <class T>   struct diff_t {     std::size_t i; //index     T v;  //value at that index     persistent_array<T> t;  //the base array     diff_t (std::size_t i, T const& v, persistent_array<T> const& t)        : i{i}, v{v}, t{t}      {}   };    //The definition of the sum ¡array_data<T>¡ is achieved via   //inheritance and a forwarding constructor   template <class T>   struct array_data : sum_type<array_t<T>, diff_t<T>> {     using base_type = sum_type<array_t<T>, diff_t<T>>;     template <class U, class... Args>       array_data (constructor<U> t, Args&&... args)     : base_type{t, std::forward<Args>(args)...}     {}   };   //¡make (n, val)¡ returns a persistent array containing ¡n¡ copies   //of ¡val¡   template <class T>   persistent_array<T> make (int n, T const& val) {     return persistent_array<T>{       new array_data<T>{constructor<array_t<T>>{}, n, val}};   }    //To implement ¡get¡ we consider the two cases. Either the   //persistent array is an immediate array, or we need to consider   //the indirection and possibly recursively access another   //persistent array   template <class T>   T const& get (persistent_array<T> const& t, std::size_t i) {     return t->match<T const&>(       [=](array_t<T> const& a) -> T const& {          return a.data[i];        }     , [=](diff_t<T> const& d)  -> T const& {          return (i == d.i) ? d.v : get (d.t, i); });   }   //¡set¡ is where the subtlety is concentrated. The idea is to keep   //the efficiency of a usual array on the very last version of the   //persistent array, while possibly decreasing the efficiency of   //previous versions   template <class T>   persistent_array<T> set (       persistent_array<T> const& t//preserve conceptual ©constness©     , std::size_t i, T const& v) {     return t->match<persistent_array<T>>(       [&t, &v, i](array_t<T>& a) -> persistent_array<T> {         T old = a.data[i];         a.data[i] = v;         //¡res¡ will be the newest version         persistent_array<T> res{           new array_data<T>{constructor<array_t<T>>{}, std::move (a.data)}};         //Now, replace the contents of ¡t¡ with an indirection         *(const_cast<persistent_array<T>&>(t)) = array_data<T>{constructor<diff_t<T>>{}, i, old, res};         return res;       }     , [t, v, i](diff_t<T>& d) -> persistent_array<T> {         return persistent_array<T>{           new array_data<T>{constructor<diff_t<T>>{}, i, v, t}};       });   }    //¡ostream¡ inserter for persistent arrays   template <class T>   std::ostream& operator << (      std::ostream& os, persistent_array<T> const& t) {     return t->match<std::ostream&>(       [&](array_t<T> const& a) -> std::ostream& {         os << "[| ";         std::copy (a.data.begin (), a.data.end ()                    , std::ostream_iterator<T>(os, "; "));         os << "|]";         return os;       }       , [&](diff_t<T> const& d) -> std::ostream& {         os << "Diff (";         os << d.i << ", " << d.v << ", " << d.t;         os << ")";         return os;       });   }    //Return a string representation of the given persistent array   template <class T>   std::string string_of_persistent_array (persistent_array<T> const& t) {     std::ostringstream os;     os << t;     return os.str ();   }   }//namespace detail    //Wrap this thing up with an object-oriented facade   template <class T>   class persistent_array {   private:     detail::persistent_array<T> impl_;   private:     persistent_array (detail::persistent_array<T> a)       : impl_{a}     {}   public:      persistent_array (int n, T const& val)       : impl_{detail::make (n, val)}     {}     T const& get (std::size_t i) const {       return detail_::get (impl_, i);     }      persistent_array<T> set (std::size_t i, T const& val) const {       return persistent_array<T>{detail::set (impl_, i, val)};     }     std::string as_string () const {       return detail::string_of_persistent_array (impl_);     }   }; }//namespace<anonymous>  TEST (pgs, array) {   persistent_array<int> a0{7, 0};   persistent_array<int> a1 = a0.set (1, 7);   persistent_array<int> a2 = a1.set (2, 8);   persistent_array<int> a3 = a1.set (2, 9);   ASSERT_EQ (     a0.as_string ()   , std::string ("Diff (1, 0, Diff (2, 0, [| 0; 7; 8; 0; 0; 0; 0; |]))"));   ASSERT_EQ (     a1.as_string ()   , std::string ("Diff (2, 0, [| 0; 7; 8; 0; 0; 0; 0; |])"));   ASSERT_EQ (     a2.as_string ()   , std::string ("[| 0; 7; 8; 0; 0; 0; 0; |]"));   ASSERT_EQ (     a3.as_string ()   , std::string ("Diff (2, 9, Diff (2, 0, [| 0; 7; 8; 0; 0; 0; 0; |]))")); } Lastly, here©s an OCaml version again, this time augmenting the basic idea with "rerooting": module type Persistent_array_sig = sig    type   t (*the array type*)    val init : int -> (int ->  ) ->   t   val make : int ->   ->   t    val get :   t -> int ->     val set :   t -> int ->   ->   t   val string_of_array : (  -> string) ->   t -> string    end  module Persistent_array : Persistent_array_sig = struct     type   t =   data ref   and   data = Arr of   array | Diff of int *   *   t    let init (n : int) (f : int ->  ) :   t =      ref (Arr (Array.init n f))    let make (n : int) (x :  ) =      ref (Arr (Array.make n x))    let rec reroot (t :   t) : unit =     match !t with     | Arr _ -> ()     | Diff (i, v, t©) ->       reroot t©;       begin          match !t© with         | Arr a as n ->           let v© = a.(i) in           a.(i) <- v;           t := n;           t© := Diff (i, v©, t)         | Diff _ -> assert false       end    let rec get (t :   t) (i : int) :   =      match !t with     | Arr a -> a.(i)     | Diff _ ->       reroot t;       begin match !t with       | Arr a -> a.(i)       | Diff _ -> assert false       end    let rec set (t :   t) (i : int) (v :  ) :   t =     reroot t;     match !t with     | Arr a as n ->       let old = a.(i) in       a.(i) <- v;       let res = ref n in       t := Diff (i, old, res);       res     | Diff _ -> assert false    let rec string_of_array (f :   -> string) (t :   t) : string =     match !t with     | Arr a ->        "[|" ^          (String.concat "; " (List.map f (Array.to_list a)))        ^ "|]"     | Diff (i, v, t©) ->        "Diff ("        ^ (string_of_int i)        ^ ", "        ^ (f v)        ^ ", "        ^ (string_of_array f t©) ^ ")" end 