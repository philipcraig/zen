
html,
    h1 {
    font-family: Helvetica, Geneva, Arial,  SunSans-Regular, sans-serif 
    }
    body {
    font-family:Verdana, Geneva, sans-serif; 
   }
Weekly Exercises : #031
2016-10-26 by 
Difficulty level :
Medium/Hard
Problem :
Type-classes are a really nifty feature of the Haskell programming language providing a feature of "parameteric overloading" also known as "bounded polymorphism". OCaml on the other hand, does not provide type-classes. They can be emulated though. Implementing them requires the programmer be explicit - no implicit support is provided by the compiler. There is more than one way to implement an emulation.

The challenge this week is to provide OCaml equivalents of the following Haskell programs.
(1)
  class Show a where
    show :: a -> string


  instance Show Int where
    show x = Prelude.show x -- internal


  instance Show Bool where
    str True = "True"
    str False = "False"


  -- Parameterically overloaded function
  print :: Show a => a -> IO ()
  print x = putShowLn$ str x

  -- Instantation
  test_print :: IO ()
  test_print = print True
(2)
  class Num a where
    fromInt :: Int -> a
    (+)     :: a -> a -> a


  sum :: Num a => [a] -> a
  sum ls = foldr (+) (fromInt 0) ls

  -- Sample instance
  instance Num Int where
    fromInt x = x
    (+)       = (Prelude.+)

  -- Two constraints
  print_incr :: (Show a, Num a) => a -> IO ()
  print_incr x = print$ x + fromInt 1

  -- Instantation of the above
  print_incr_int :: Int -> IO
  print_incr_int x = print_incr x
(3)
  -- An instance with a constraint
  instance Show a => Show [a]   where
    show xs = "[" ++ go True xs
      where
        go _ [] = "]"
        go first (h:t) =
         (if first then "" else ", ")  ++ show h ++ go False t


   testls :: String
   testls = show [1::Int, 2, 3]
(4)
  class Eq where
    (==) :: a -> a -> bool
    (/=) :: a -> a -> bool


  deriving instance Eq Bool
  deriving instance Eq Int

  -- Type-class with a super-classes and a default method
  class (Eq a, Num a) => Mul a where
    (*) :: a -> a -> a
    x * _ | x == fromInt 0 = fromInt 0
    x * y | x == fromInt 1 = y
    x * y | y + (x + (fromInt (-1))) * y

  instance Mul Bool where
    -- default


  instance Mul Int where
    x * y = (Prelude.*) x y -- internal

  -- Dot product. There is only one constraint
  dot :: Mul a -> [a] -> [a] -> a
  dot xs ys = sum$ zipWith (*) xs ys

  test_dot :: Int
  test_dot = dot [1, 2, 3] [4, 5, 6]
(5)
  -- Polymorphic recursion


  print_nested :: Show a => Int -> a -> IO ()
  print_nested 0 x = print x
  print_nested n x = print_nested (n - 1) (replicate n x)
  test_nested = do
    n <- getLine
    print_nested (read n) (5::Int)
