==========================
 Weekly OCaml exercise #2
==========================

Difficulty level : Easy

Problem :

If S is a set, then P(S), the 'powerset' of S is the set of all
subsets of S including the empty set and S itself. If S has
cardinality N then the cardinality of P(S) is 2^N (why?).

Write the function 'powerset' that computes the powerset of a given
set. Your function will satisfy this signature:
::

  val powerset : 'a list -> 'a list list 

For example, in the top-level:
::

  # sets [1; 2; 3] ;;
  - : int list list = [[]; [3]; [2]; [2; 3]; [1]; [1; 3]; [1; 2]; [1; 2; 3]]

The ordering of the sets is not important here, just that all the
required sets are discovered.

As before, please submit your solutions to me on MSG. To help me find
them easily, please use the subject line, "Weekly OCaml exercise #2".

Have a good weekend!

::

  (*Eugene Perederey*)
  let rec sets = function
    | [] -> [[]]
    | (x::xs) -> 
       let ps = sets xs in
       List.concat [ps; List.map (fun l -> x::l) ps]  
  ;;  

  (*Geoffrey Hinkley*)
  let powerset l =
    let rec powersetImpl ps t = 
       match t with
        | [] -> ps
        | (hd :: t2) ->
          let withHd = List.map (fun s -> hd::s) ps
          in
          powersetImpl (ps @ withHd) t2
    in
    powersetImpl [[]] l

  (*Enrique Naudon*)
  (**
   *
   *  SOLUTION 1: The list module way.
   *
   **)
  (**
   *  Iterate over the elements (elem) in S, accumulating elem as well as the
   *  concatenation of elem and the previously accumulated elements.
   **)
  let powerset_foldl s =
    let helper acc elem =
      let sets = List.map (fun l -> elem :: l) acc in
      sets @ acc
    in
    List.fold_left helper [[]] s
  (**
   *
   *  SOLUTION 2: The bit-twiddling way.
   *
   **)
  (**
   *  Computes the binary log
   **)
  let binary_log i =
    let f = float_of_int i in
    let log2 = (log f) /. (log 2.) in
    int_of_float log2
  (**
   *  Returns the set bits
   **)
  let find_set_bits i =
    let rec loop acc i = match i with
      | 0 -> acc
      | i ->
        let fsb = binary_log i in
        loop (fsb :: acc) (i - (1 lsl fsb))
    in
    loop [] i
  (**
   *  The power set of S is the set of all possible combinations of the
   *  elements in S, so all we need is a way to structure our search through
   *  that space.  In this solution I use the bit patterns of the numbers
   *  between 0 and 2^N to generate those combinations.
   *
   *  NOTE: this is linear in the cardinality of P(S), assuming we can compute
   *  the binary log efficiently, which we can on many architectures (e.g.
   *  lzcnt on x86, clz on ARM/MIPS).
   *
   *  NOTE: This won't work with sets with a cardinality greater than the max
   *  integer!
   **)
  let powerset_twiddle s =
    let arr = Array.of_list s in
    let rec loop acc i = match i with
      | 0 -> acc
      | i ->
        let helper acc i = (Array.get arr i) :: acc in
        let inc = find_set_bits i in
        let sets = List.fold_left helper [] inc in
        loop (sets :: acc) (i - 1)
    in
    loop [[]] (1 lsl (Array.length arr) - 1)

    (*Enrique further writes

    Honestly I was struggling to explain in the comments (i.e. without
    pencil and paper).  I'll give it another shot...  Like I said, the
    P(S) is the set of all combinations of the elements in S.  So
    constructing an arbitrary subset of S is just a matter of deciding for
    each element of S whether or not we include it.  The way I construct
    the power set is by counting from 0 to (2^N)-1; call my iterator i.
    To construct the ith subset, I include the nth element in S only if
    the nth bit in i is set.  For the set {1,2,3} we count from 0 to 4,
    since N = 3.  Here's what each of those iterations looks like:
    
    i  binary  fsb(i)   corresponding subset
    0 | 0000 | {}      | {}
    1 | 1000 | {0}     | {1}
    2 | 0100 | {1}     | {2}
    3 | 1100 | {0,1}   | {1,2}
    4 | 0010 | {2}     | {3}
    5 | 1010 | {0,2}   | {1,3}
    6 | 0110 | {1,2}   | {2,3}
    7 | 1110 | {0,1,2} | {1,2,3}
    
    Does that make sense?
    
     *)
