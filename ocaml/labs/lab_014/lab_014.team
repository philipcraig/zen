
html,
    h1 {
    font-family: Helvetica, Geneva, Arial,  SunSans-Regular, sans-serif 
    }
    body {
    font-family:Verdana, Geneva, sans-serif; 
   }
Weekly Exercises : #14
2015-05-29 by 
Difficulty level :
Easy
Problem :
Let's sharpen up! If you've skipped out of these exercises for a while, take the chance to get back into the fray! If you haven't submitted before, here's your chance to get started! This is an easy one for real - shouldn't take you more than 15 minutes (smile)

Implement the so-called "runtime-length encoding data compression method". For our purposes, it's enough to do this:
Write a function that packs consecutive elements of a list into sublists. For example, given let x = pack ['a';'a';'a';'a';'b';'c';'c';'a';'a';'d';'e';'e';'e';'e'] we expect x to have the value, [['a';'a';'a';'a'];['b'];['c';'c'];['a';'a'];['d'];['e';'e';'e';'e']]
In the next step, encode the result of pack into a list of pairs (n, e) where n is the number of occurrences of the expression e. For example, given let y = encode (pack ['a';'a';'a';'a';'b';'c';'c';'a';'a';'d';'e';'e';'e';'e']) then we expect y to have the value [(4, 'a'); (2, 'c'); (2, 'a'), (1, d); (4, 'e')].
Write a function to decode a list given in runtime-length encoded data compressed format as defined above.
Solutions expected by close of business this coming Friday!
 
::

  (*Me*)

  let pack (x : char list) : char list list =
    let f (acc : char list list) (c : char) : char list list =
      match acc with
      | (((b :: _) as hd) :: tl) when c = b-> (c :: hd) :: tl
      |  _ -> [c] :: acc
    in List.fold_left f [] x
  
  let encode (x : char list list) : (int * char) list =
    let f (acc : (int * char) list) (l : char list) : (int * char) list =
      (List.length l, List.hd l) :: acc
    in List.fold_left f [] x
    
  let decode (data : (int * char) list) =
    let repeat ((n : int), (c : char)) : char list =
      let rec aux acc i = if i = 0 then acc else aux (c :: acc) (i - 1) in
      aux [] n in
    let f (acc : char list) (elem : (int * char)) : char list =
      acc @ (repeat elem) in
    List.fold_left f [] data

  (*Viet Li*)  

  (* Packing function *)
  let pack_aux a b = match a with | [] -> [[b]]
      | (h :: _) as h1 :: t -> if h = b then (b :: h1) :: t else [b] :: h1 :: t
      | _ -> failwith "Invalid input"
  let pack l = List.rev @@ List.fold_left pack_aux [] l
  
  (* Encoding function *)
  let encode_aux acc = function | h :: _ as l -> (List.length l, h) :: acc | _ -> failwith "Invalid input"
  let encode l = List.rev @@ List.fold_left encode_aux [] l
  
  (* Decoding function *)
  let rec generate acc (count, v) = if count > 0 then generate (v :: acc) (count - 1, v) else acc
  let decode l = List.rev @@ List.fold_left generate [] l
  

  (*Eugene Perederey*)

  let rec partition pred = function
    | [] -> ([], [])
    | (x :: xs) when pred x -> let pass, fail = partition pred xs in
                               (x :: pass, fail)
    | fail -> ([], fail)
  
  let rec pack = function
    | [] -> []
    | (x :: xs) -> let g, gs = partition (fun y -> y = x) xs in
                   (x :: g) :: pack gs
  
  let encode = List.map (fun g -> List.length g, List.hd g)

  let rec repeat c = function | n when n <= 0 -> [] | n  -> c :: repeat c (n - 1)

  let decode gs = List.concat (List.map (fun (n, c) -> repeat c n) gs)

  (*Harvey Stein*)

  (defun rle (l)
    (cond ((null l) ())
          ((null (cdr l)) `((1 ,(car l))))
          (t (rle-aux (cdr l) (car l) 1))))
  
  (defun rle-aux (l item n)
    (cond ((null l) `((,item ,n)))
          (t (if (eq (car l) item)
                 (rle-aux (cdr l) item (1+ n))
               (cons (list n item) (rle-aux (cdr l) (car l) 1))))))

Here's a tighter version - Used a local function & cleaned up the conditonals...:

[34]> (defun rle (l)
  (labels ((rle-aux (l item n)
                  (cond ((null l) `((,n ,item)))
                        ((eq (car l) item)
                         (rle-aux (cdr l) item (1+ n)))
                        (t (cons `(,n ,item) (rle-aux (cdr l) (car l) 1))))))
    (cond ((null l) ())
          (t (rle-aux (cdr l) (car l) 1)))))


  RLE
  [35]> (rle2 '())
  
  NIL
  [36]> (rle2 '(d))
  
  ((1 D))
  [37]> (rle2 '(d d))
  
  ((2 D))
  [38]> (rle2 '(a a a b  c c c d d d d d e))
  
  ((3 A) (1 B) (3 C) (5 D) (1 E))
  [39]> 
  
