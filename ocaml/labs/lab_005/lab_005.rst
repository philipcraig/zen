==========================
 Weekly OCaml exercise #5
==========================

Difficulty level : Easy/Medium

Problem :

The sieve of Eratosthenese is a simple, beautiful algorithm from antiquity for finding all prime numbers up to any limit. It works iteratively by marking as composites the multiples of each prime, starting with 2. It is in fact, one of the most efficient ways known to find all of the smaller primes.

For example, to find the prime numbers less than 10, start with the list [1; 2; 3; 4; 5; 6; 7; 8; 9]. Removing multiples of 2 you get the list [1; 2; 3; 5; 7; 9], then removing multiples of 3 you get [1; 2; 3; 5; 7] and since there are no multiples of 5 or 7 for this limit, we are done.

This week, the problem is to produce an implementation of this algorithm. To test, show that your program correctly finds all primes below 121.

There are so many ways to express an answer to this problem... For the truly adventourous, Xavier Leroy's "Unix System Programming in OCaml" (http://ocaml.github.io/ocamlunix/index.html), section 5.2,  presents a parallel multi-process solution!

Solutions
::

  (*Shayne*)
  let mk_fil k tl = fun i -> 
    if i mod k = 0 then None else tl i
  let f (acc, s) = fun i -> 
    match s i with
      | Some p -> (p :: acc, mk_fil p s)
      | _ -> (acc, s)
  let l = List.rev (fst (List.fold_left f ([2], mk_fil 2 (fun x -> Some x)) (range 3 122)))
