\chapter{Pricing using Numerical Methods}
\label{ch:pricing-using-numerical-methods}

As the demand for ever more complex financial structures grows and the
trend towards multi-asset products accelerates, quantitative analysts
will resort more and more to numerical methods to solve their pricing
problems.  The two most common approaches currently in use today are
Monte-Carlo simulation and lattice integration schemes, for example
finite difference. In this chapter we will develop a general framework
for both approaches that can be used to price a large set of pricing
problems. The ultimate goal of the chapter is to arrive at a design
where the pricing frameworks are invariant over the pricing model
used.

\section{A lattice pricing framework} \label{DomainSpaceIntegration}
Let us begin this section by outlining the domain of problems the
lattice pricing framework to be developed will be able to
handle. Firstly the pricing model needs to be a low-dimensional
Markovian model otherwise the time taken to price becomes
prohibitive; and secondly the financial instrument must not be
path-dependent. If these two criteria are satisfied, then the
following framework is applicable. The second criterion can be
relaxed, through the introduction of state-variables, to include only
strongly path-dependent instruments. However this next step is beyond
the scope of the book and we leave it as an exercise for the reader.

The aforementioned criteria restrict the universe of pricing problems
to a class of instruments commonly referred to as `vanilla' callable
libor exotics. A typical instrument is made up of two legs, a funding
leg and an exotic coupon leg, together with an exercise schedule. The
funding leg is simply a strip of cash flows at regular intervals
paying libor plus a spread. The exotic coupon leg consists of a strip
of cash flows at regular intervals paying some function of libor, for
example a libor collar. The exercise schedule gives the holder of the
financial instrument the right to cancel or call the trade, again at
regular intervals. Typically the exercise decision dates fall on one
of the reset dates of the cash flows - otherwise a stub payment usually
has to be paid if an exercise decision falls mid-way through the
accrual period of a cash flow. We will restrict ourselves to the case
of no stub flows. Note that the combination of the funding leg and
exotic coupon leg is referred to as a swap because the holder usually
pays, or receives, the exotic coupon cash flows in exchange for receiving,  
or paying, the funding cash flows.

Let us denote the pricing date by $T_0$, the exercise decision dates
by $T_1 < T_2 < ... < T_M$, the pricing numeraire by $N_{T_{i}}$ and
the expectation in the pricing measure by $\mathbb E$.  The price of
the callable trade can be written as follows

\begin{equation}\label{eq:callable_price}
N_{T_i}^{-1} V^{call}_{T_i} = max(\mathbb E[N_{T_{i+1}}^{-1}V^{call}_{T_{i+1}}| \mathcal F_{T_i}], N_{T_i}^{-1} V^{swap}_{T_i})  
\end{equation}

with boundary condition 

\begin{equation}
V^{call}_{T_{M+1}} = 0
\end{equation}

Here $V^{call}_{T_i}$ represents the price of the callable structure
at $T_i$ and similarly $V^{swap}_{T_i}$ denotes the price of the
underlying swap at $T_i$. In other words we iterate backwards through
the list of exercise decision dates, evaluating the equation
\ref{eq:callable_price} on each exercise decision date until we reach
$T_0$, the pricing date. Next we denote the union of the cashflow
payment dates by $t_1 < t_2 < ... < t_N$ and the value of the cash
flow payments at $t_i$ by $V^{cf}_{t_i}$. Then the price of the
underlying swap at $T_i$ is given by the summation below

\begin{equation}
V^{swap}_{T_i} = N_{T_i} \sum_{k = n(T_i)}^N \mathbb E[N_{t_{k}}^{-1} V^{cf}_{t_k} | \mathcal F_{T_i}]
\end{equation}

with $T_i <= t_k ~\forall k >= n(T_i)$. The conditional expectations,
in the equations above, are calculated on the lattice of the
pricing model. Note that the price of the cancellable trade is simply
the price of the underlying swap plus the price of the callable on the
reverse of the underlying swap (i.e. with the pay and receive legs
swapped around).

Now that we understand how to price the trades we need to set about
writing a pricer to price them. Fortunately we already have all the
fundamental building blocks to hand. Before we go on to discuss the
implementation of the pricer in detail, we must first return to the
controller and add a few more methods. The following code excerpt from
\verb|ppf.core.controller| contains the new methods. When pricing we
need to maintain the state of various symbols required in the
calculation, for example a symbol for the value of the underlying. We
also need to know when the symbol was last updated - this is necessary
during arithmetic operations on the values of two symbols, such as
addition. Before carrying out the arithmetic operation we must first
ensure that the two symbols are synchronised, that is they were last
updated at the same time. If one of the symbols was last updated at a
later time (recall we iterate backwards in time), then we need to
rollback, or equivalently perform a conditional expectation on, the
value of the symbol to the time of the other symbol. The method
\verb|retrieve_symbols_to_rollback()| on the controller queries the
symbol table for all symbols with a last update time later than the
specified time \verb|at|.  The remaining two methods \verb|rollback()|
and \verb|rollback_max()| rollback a symbol or the maximum of two
symbols from time \verb|T| to time \verb|t|. The actual calculation of
the conditional expecations is carried out by the rollback component
of the model stored in the controller.

\begin{verbatim}
class controller:
  def retrieve_symbols_to_rollback(self, at):
    symbols = []
    for symbol in self.__symbol_table:
      pair = self.__symbol_table.get(symbol)
      if pair[0] > at:
        symbols.append(symbol)
    return symbols

  def rollback(self, T, t, symbol):
    requestor = self.__model.requestor()
    state = self.__model.state()
    return self.__model.rollback().rollback(t, T, state\
             , requestor, self.__env, symbol)

  def rollback_max(self, T, t, symbol_one, symbol_two):
    requestor = self.__model.requestor()
    state = self.__model.state()
    res1 = self.__model.rollback().rollback(t, T, state\
             , requestor, self.__env, symbol_one)
    res2 = self.__model.rollback().rollback_max(t, T, state
             , requestor, self.__env, symbol_two-symbol_one)
    return res1+res2
\end{verbatim} 

The following excerpt from \verb|ppf.pricer.lattice_pricer|
illustrates the details of the lattice pricer. The pricer is
constructed by passing in the trade, the model, the market environment
and an optional object called a symbol table listener. In the body of
the constructor itself we check that the trade contains no stubs and
then construct the timeline from the trade and the pricing date. 
\begin{verbatim}
class lattice_pricer:
  def __init__(self, trade, model, env, symbol_table_listener = None):
    self.__trade = trade
    self.__model = model
    self.__env = env
    self.__symbol_table_listener = symbol_table_listener
    # check no stubs
    trade_utils.enforce_no_exercise_stubs(trade)
    # create timeline
    self.__timeline = timeline(trade, env.pricing_date())   

  def __symbol_listener_(self, t, symbol, value):
    if self.__symbol_table_listener:
      self.__symbol_table_listener(t, symbol, value, self.__model, self.__env)
\end{verbatim}
The main method of the pricing framework is the function call operator: it
is this method that performs the actual pricing. We will step through
this method line by line highlighting the main features. The first
thing we do is construct a controller - recall this is the class that
provides the conduit between the pricing framework and the pricing
model. We then retrieve the dates on which conditional expectations
need to be calculated. We do this by calling the \verb|times| method
on the timeline: on each of these times a collection of events will
have been registered during the construction of the timeline. We
conclude the set up phase of the pricing by injecting the symbols
`underlying', `berm', `leg0', `leg1', ... into the symbol
table of the controller. Each of these symbols has an initial value of
zero.
\begin{verbatim}
class lattice_pricer:
  def __call__(self):
    # create controller
    ctr = controller(self.__trade, self.__model, self.__env)
    times = self.__timeline.times()
    from_ = self.__env.relative_date(times[-1])/365.0
    # initialise symbols
    ctr.insert_symbol("underlying", from_)
    ctr.insert_symbol("berm", from_)
    cnt = 0
    for l in self.__trade.legs():
      symbol = "leg"+str(cnt)
      ctr.insert_symbol(symbol, from_)      
      cnt += 1
    .
    .
    .
\end{verbatim}
We now come to the main loop. Here we iterate backwards through the
list of times from the timeline, maintaining two time variables
\verb|from_| and \verb|to_|. \verb|from_| denotes the current time, as
a year fraction, at which the events are to be evaluated and
\verb|to_| denotes either the next time (in the timeline) or the
pricing date, again as a year fraction. At each time we again query
the timeline for the collection of events registered at the current
time. Once we have the list of events we iterate through them in the
order they were registered. The event to be evaluated is passed into
the controller via the \verb|set_event| method. If the event is a pay
event , i.e. a cash flow, we delegate to the function call operator of
the controller to perform the actual evaluation. After evaluating the
pay event, the corresponding symbol for the present value of the leg
is retrieved from the symbol table and its value is incremented by the
current value of the event. On completion of the evaluation, the value
of the corresponding leg symbol is updated in the symbol table. If the
event represents an exercise decision, then we compute the underlying
by retrieving the values of the leg symbols and adding them
together. The value of the callable, denoted by \verb|berm|, is then
computed via an invocation of the \verb|rollback_max| method on the
controller.  Finally the underlying is also rolled back using the
\verb|rollback| method on the controller and both the value of the
underlying and that of the callable are updated in the symbol
table. Note that the underlying is multiplied by the exercise type of
the trade prior to performing the calculation of the bermudan. This
way we can evaluate both callable and cancellable instruments within a
uniform framework.
\begin{verbatim}
class lattice_pricer:
  def __call__(self):
    .
    .
    .
    # reverse iterate through the timeline
    for i in range(len(times)-1,-1,-1):
       time = times[i]
       to_ = 0
       if i <> 0:
         to_ = self.__env.relative_date(times[i-1])/365.0
       events = self.__timeline.events(time)
       for event in events:
         # set event on controller
         ctr.set_event(event)
         # evaluate
         if is_pay_event(event):
           # evaluate payoff
           cpn = ctr(from_)
           # rollback symbol
           symbol = "leg"+str(event.leg_id())
           leg_pv = ctr.retrieve_symbol(symbol) 
           leg_pv += cpn        
           self.__symbol_listener_(from_, symbol, leg_pv)
           ctr.update_symbol(symbol, leg_pv, to_)           
         else:
           # evaluate underlying             
           underlying = ctr.retrieve_symbol("underlying")
           underlying *= 0 # not pretty
           cnt = 0
           for l in self.__trade.legs():
             underlying += ctr.retrieve_symbol("leg"+str(cnt))         
             cnt += 1
           self.__symbol_listener_(from_, "underlying"\
              , self.__trade.exercise_type()*underlying)
           # rollback berm
           berm = ctr.retrieve_symbol("berm")
           self.__symbol_listener_(from_, "berm", berm)
           berm = ctr.rollback_max(from_, to_, berm\
             , self.__trade.exercise_type()*underlying)
           # rollback underlying
           underlying = ctr.rollback(from_, to_, underlying)
           # update symbols
           ctr.update_symbol("underlying", underlying, to_)
           ctr.update_symbol("berm", berm, to_)
    .
    .
    .
\end{verbatim}
After all the events at a particular time have been evaluated we have
to retrieve all the symbols in the symbol table that haven't yet been
rolled back to \verb|to_| and roll them back. The computation of the
symbols requiring a roll back operation is carried out by the
\verb|retrieve_symbols_to_rollback| method of the controller. The
final phase of the pricer is the calculation of the present value of
the trade. The only complication here is to decide whether the trade
has an exercise schedule and, if so, whether the exercise type is
callable or cancellable. In the case of the exercise type being
cancellable the present value is the sum of the mean of the callable
value and the mean of the underlying value, otherwise the present
value is simply the mean of the callable value. If the trade has no
exercise schedule, then the present value is just the mean of the
underlying value.  Note that the mean is calculated using the
\verb|mean| method on the NumPy array.
\begin{verbatim}
class lattice_pricer:
  def __call__(self):
    .
    .
    .
       # rollback any symbols in symbol table not already rolled back
       symbols = ctr.retrieve_symbols_to_rollback(to_)
       for symbol in symbols:
         from_ = ctr.retrieve_symbol_update_time(symbol)
         value = ctr.retrieve_symbol(symbol)
         value = ctr.rollback(from_, to_, value)
         ctr.update_symbol(symbol, value, to_)
       from_ = to_
    # calculate pv
    underlying = ctr.retrieve_symbol("underlying")
    underlying *= 0
    cnt = 0
    for l in self.__trade.legs():
      underlying += ctr.retrieve_symbol("leg"+str(cnt))         
      cnt += 1
    ctr.update_symbol("underlying", underlying, to_)
    pv = 0
    if self.__trade.has_exercise_schedule():
      if self.__trade.exercise_type() == exercise_type.callable:
        pv = ctr.retrieve_symbol("berm").mean()
      else:
        pv = ctr.retrieve_symbol("underlying").mean() \
                 + ctr.retrieve_symbol("berm").mean()
    else:
      pv = ctr.retrieve_symbol("underlying").mean()
    return pv
\end{verbatim}

It needs to be emphasised that in the above pricing framework there is
theoretically no restriction on the dimensionality of the
model. Everything will flow through just as well for a
multi-dimensional model, albeit more slowly, as it would do for a
one-dimensional model. The only assumption being made on the
underlying numerical container is that it has the arithmetic operators
overloaded and a mean operator.

To conclude this section, we note that sometimes it is useful for
diagnostics purposes to be able to listen to the symbols at various
stages of the calculation. The optional \verb|symbol_table_listener|
argument in the constructor provides this functionality. A concrete
example, provided in the test module
\verb|ppf.test.test_lattice_pricer|, is given below:
\begin{verbatim}
class european_symbol_table_listener:
  def __init__(self):
    self.__symbols = []
  def __call__(self, t, symbol, value, model, env):
    if symbol == "underlying":
      requestor = model.requestor()
      state = model.state()
      self.__symbols.append( model.rollback().rollback_max(0.0, t, state\
        , requestor, env, value).mean())

  def retrieve_symbols(self):
    return self.__symbols  
\end{verbatim} 
The purpose of the above listener is to store the European option
prices at various stages of the pricing. The listened symbols can then
be retrieved via an invocation of the \verb|retrieve_symbols| method
on the listener.

\section{A Monte-Carlo pricing framework} \label{MonteCarlo} 
Our aim in this section is to develop a Monte-Carlo pricing framework
similar in spirit to the lattice pricing framework already
developed. Suppose $Y$ is a random variable, the core idea behind
Monte-Carlo pricing is to simulate the value of $Y$ many times and
approximate the expectation of $Y$ by the following discrete sum
\begin{equation}
\mathbb E[Y] \approx \sum_{i=1}^n w_i Y_i
\end{equation}
where $Y_i$ denotes the $i$'th simulation (or draw) of the value of
$Y$ and $w_i$ denotes the associated weight. In most applications the
weights are uniform and set to $\frac{1}{n}$.  By Kolmogorov's strong
law of large numbers, as $n \rightarrow \infty$ the above
approximation becomes exact.

It should come as no surprise that we need to add a method onto the
controller. The new method is called \verb|evolve| and is detailed
below.  The implementation is simple, with the actual evolve operation
being delegated to the evolve component on the model.
\begin{verbatim}
  def evolve(self, t, T):
    requestor = self.__model.requestor()
    state = self.__model.state()
    self.__model.evolve().evolve(t, T, state, requestor, self.__env)
\end{verbatim}

In the next two subsections we develop the pricing framework for
pricing both non-callable and callable structures, beginning with
non-callable structures.

\subsection{Pricing non-callable trades}
The implementation of the Monte-Carlo pricer is in the
\verb|ppf.pricer.monte_carlo_pricer| module. To simplify the
exposition we only concentrate on those pieces of code from the module
needed for pricing non-callable trades. Like the lattice pricer, the
Monte-Carlo pricer is constructed by passing in the trade, the model,
the environment and an optional symbol table listener. 
\begin{verbatim}
class monte_carlo_pricer:
  def __init__(self, trade, model, env, symbol_table_listener = None):
    self.__trade = trade
    self.__model = model
    self.__env = env
    self.__symbol_table_listener = symbol_table_listener
    # check no stubs
    trade_utils.enforce_no_exercise_stubs(trade)
    # create timeline
    self.__timeline = timeline(trade, env.pricing_date())   

  def __symbol_listener_(self, t, symbol, value):
    if self.__symbol_table_listener:
      self.__symbol_table_listener(t, symbol, value, self.__model, self.__env)
\end{verbatim}
The actual pricing is carried out by the function call operator. Again we step
through the implementation of the function call operator line by
line. We start by creating the controller. Then we query the timeline
for the list of times on which events have been registered. After
initialising the \verb|berm|, \verb|underlying|, \verb|leg0|,
\verb|leg1|, ... variables to zero and the time \verb|from_| to zero,
we come to the main loop. 
\begin{verbatim}
class monte_carlo_pricer:
  def __call__(self, symbol_value_pairs_to_add = None):
    # create controller
    ctr = controller(self.__trade, self.__model, self.__env)
    times = self.__timeline.times()
    from_ = 0.0
    # initialise symbols
    ctr.insert_symbol("underlying", from_)
    ctr.insert_symbol("berm", from_)
    # add extra symbols
    if symbol_value_pairs_to_add:
      for symbol_value_pair in symbol_value_pairs_to_add:
        symbol, value = symbol_value_pair
        ctr.insert_symbol(symbol, value)
    cnt = 0
    for l in self.__trade.legs():
      symbol = "leg"+str(cnt)
      ctr.insert_symbol(symbol, from_)      
      cnt += 1
    .
    .
    .
\end{verbatim}
In the main loop we iterate forwards in time
through the list of times. At each time we invoke the \verb|evolve|
operator on the controller to evolve from time \verb|from_| to time
\verb|to_| all state variables, required by the model to calculate the
payoff, forwards in time. At each time we loop through the events
registered at that time and invoke the function call operator on the
controller to calcluate the payoff. The corresponding leg variable is
retrieved from the symbol table, incremented by the value of the cash
flow and pushed back into the symbol table. At the end of the events
loop we update the time \verb|from_| to \verb|to_|. The calculation of
the pv returned by the function call operator is exactly the same as
for the lattice pricer and needs no further comment.

\begin{verbatim}
class monte_carlo_pricer:
  def __call__(self, symbol_value_pairs_to_add = None):
    .
    .
    .
    # forward iterate through the timeline
    for time in times:
      to_ = self.__env.relative_date(time)/365.0
      # evolve
      ctr.evolve(from_, to_)
      events = self.__timeline.events(time)
      for event in events:
        # set event on controller
        ctr.set_event(event)
        # evaluate
        if is_pay_event(event):
          # evaluate payoff
          cpn = ctr(from_)
          symbol = "leg"+str(event.leg_id())
          leg_pv = ctr.retrieve_symbol(symbol) 
          leg_pv += cpn        
          self.__symbol_listener_(to_, symbol, leg_pv)
          ctr.update_symbol(symbol, leg_pv, to_)                      
        else:
          raise RuntimeError, 'callables not yet implemented'
      from_ = to_
    # calculate pv
    pv = 0
    if self.__trade.has_exercise_schedule():
      if self.__trade.exercise_type() == exercise_type.callable:
        pv = ctr.retrieve_symbol("berm").mean()
      else:
        pv = ctr.retrieve_symbol("underlying").mean()\
               +ctr.retrieve_symbol("berm").mean()
    else:
      cnt = 0
      for l in self.__trade.legs():
        leg_pv = ctr.retrieve_symbol("leg"+str(cnt)) 
        pv += leg_pv.mean()
        cnt += 1
    return pv
\end{verbatim}

Before moving on to the pricing of callable structures, we note that
the signature of the function call operator for the Monte-Carlo pricer
differs from that of the lattice pricer. The function call operator
now takes an optional list of tuples representing symbol-value pairs
that need to be inserted into the symbol table prior to the evaluation
taking place. The reason for this addition is down to the
strongly-path dependent nature of the type of payoffs evaluated by the
Monte-Carlo pricing framework. The strongly-path dependent nature
implies the existence of variables whose history influences the
payoff and such variables need to be initialised to some starting
values.

\subsection{Pricing callable trades}
The pricing of callable structures entails finding the optimal
exercise rule by solving an optimal stopping time problem. Once the
optimal stopping time rule has been discovered, the pricing of
structure simply involves the computation of the expected discounted
payoff, subject to the stopping time rule. Let $V(t)$ denote the
discounted payoff from exercise at time $t$ and $\mathcal T$ be the
class of stopping times with values in $[0,T]$, where $T$ is the last
exercise time. The problem then becomes to find the optimal expected
discounted payoff
\begin{equation}
sup_{\tau \in T} \mathbb E[V(t)].
\end{equation}
There exist many algorithms for estimating the optimal stopping
time. However all algorithms of practical use result in either low
bias estimators or high bias estimators. A low bias estimator gives a
price for the callable that is bounded above by the true price. In a
similar fashion, a high bias estimator gives a price for the callable
that is bounded below by the true price, see \cite{book:GLASSERMAN}
for further details. We have implemented a low bias estimator in terms
of the pickup value. The pickup value at a given exercise time is just
the difference between the immediate exercise value and the value of
holding on to the option. Further details on the exact algorithm for
estimating the stopping time can be found in appendix
\ref{appendix:mc_regressions} but, broadly speaking, at each exercise
time we approximate the pickup value as a linear sum of functions of
an arbitrary number of explanatory variables and estimate the
coefficients in the sum using generalised least squares. The choice of
a linear sum of functions for the approximation is standard but other
forms have been mooted in the literature, see \cite{book:JAECKEL} for
an example applied to the pricing of Bermudan swaptions.

The implementation of our low bias estimator is taken from the \\
\verb|ppf.math.exercise_regressions| module. Stepping through the
code, we begin by defining a number of functors to represent the
constant function, the linear function and the quadratic
function. Next we define a wrapper class for all the functions used in
the approximation of the pickup value. The class is called
\verb|n_quadratic_fo| and the constructor takes in the number of
explanatory variables and builds up a list of function objects. For
example, if we have two explanatory variables $X$ and $Y$, then the
function call operator of \verb|n_quadratic_fo| simply mimics the
function
\begin{equation}
f(X,Y) = \alpha_1 + \alpha_2 X + \alpha_3 X^2 + \alpha_4 XY + \alpha_5 Y + \alpha_6 Y^2.
\end{equation} 
The final class, \verb|fitted_fo|, is simply an adaptor of the class
\verb|n_quadratic_fo| with the purpose of provided a function call
operator with a single argument. 
\begin{verbatim}
class unit_fo:
  def __call__(self, x):
    return 1.0
class linear_fo:
  def __init__(self, i):
    self.__i = i
  def __call__(self, x):
    return x[self.__i]
class quadratic_fo:
  def __init__(self, i, j):
    self.__i = i
    self.__j = j
  def __call__(self, x):
    return x[self.__i]*x[self.__j]

class n_quadratic_fo:
  def __init__(self,num_expl_vars):
    self.__fos = []
    self.__fos.append(unit_fo())
    for i in range(num_expl_vars):
      self.__fos.append(linear_fo(i))
      for j in range(i, num_expl_vars):
        self.__fos.append(quadratic_fo(i, j))
    self.__n = len(self.__fos)
  def __call__(self, alphas, x):
    y = 0.0
    for i in range(self.__n):
      y += alphas[i]*self.__fos[i](x)
    return y
  def fit_fos(self):
    return self.__fos
   
class fitted_fo:
  def __init__(self, alphas, fo):
    self.__alphas = alphas
    self.__fo = fo
  def __call__(self, x):
    return self.__fo(self.__alphas, x)
\end{verbatim}
The actual fitting of the approximate
sum to the pickup value is carried out by the free function \verb|fit|
which in turn delegates to the generalised least squares algorithm
implemented in \verb|ppf.math.generalised_least_square|. The free
function takes in the explanatory variables \verb|x| and the values to
be fitted \verb|y| and returns an instance of the class
\verb|fitted_fo|. 
\begin{verbatim}
def fit(x, y):
  if len(x.shape) <> 2:
    raise RuntimeError, "Expected 'x' to be 2d array"
  if len(y.shape) <> 1:
    raise RuntimeError, "Expected 'y' to be 1d array"
  num_obs = x.shape[0]
  num_expl_vars = x.shape[1]
  if num_obs <> y.shape[0]:
    raise RuntimeError, "'y' array has wrong size"

  fo = n_quadratic_fo(num_expl_vars)
  sig = numpy.zeros(num_obs)  
  sig.fill(1.0)
  alphas = generalised_least_squares_fit(y, x, sig, fo.fit_fos())
  return fitted_fo(alphas, fo)
\end{verbatim}
Given a fitted function, we need to be able to
evaluate it: the free function \verb|evaluate_regression|, taking in
the explanatory variables \verb|x| and the fitted function \verb|fo|,
does this for us.
\begin{verbatim}
def evaluate_regression(x, fo):
  if len(x.shape) <> 2:
    raise RuntimeError, "Expected 'x' to be a 2d array"
  num_obs = x.shape[0]
  y = numpy.zeros(num_obs)
  for i in range(num_obs):
    y[i] = fo(x[i, :])
  return y
\end{verbatim}
Finally, the actual implementation of the pickup
regression algorithm is provided in the free function
\verb|pickup_value_regression| and follows closely the mathematics in
appendix \ref{appendix:mc_regressions}.
\begin{verbatim}
# max for numpy arrays
max_ = numpy.vectorize(lambda x, y: (x, y)[x < y])

def pickup_value_regression(ies, ns, vs):
  if len(ies.shape) <> 2:
    raise RuntimeError, "Expected 'immediate exercise values' to be a 2d array"
  if len(ns.shape) <> 2:
    raise RuntimeError, "Expected 'numeraires' to be a 2d array"
  if len(vs.shape) <> 3:
    raise RuntimeError, "Expected 'explanatory variables' to be a 3d array"

  num_times = ies.shape[0]
  num_obs = ies.shape[1]
  num_expl_vars = vs.shape[2]

  if ns.shape[0] <> num_times or ns.shape[1] <> num_obs:
    raise RuntimeError, "'numeraires' array has wrong size"
  if vs.shape[0] <> num_times or vs.shape[1] <> num_obs:
    raise RuntimeError, "'explanatory variables' array has wrong size"

  fitted_fos = []
  zero = numpy.zeros(num_obs)
  H = numpy.zeros(num_obs) # holding value
  for i in range(num_times-1,-1,-1):
    x = vs[i, :, :]
    n = ns[i, :]
    pv = n*(ies[i, :]-H) # reinflate by numeraire
    fit_fo = fit(x, pv)
    temp = evaluate_regression(x, fit_fo) # pickup value regression
    fitted_fos.insert(0, fit_fo)
    H += max_(temp/n, zero) # deflate by numeraire

  return fitted_fos
\end{verbatim}

Armed with the pickup value regressions we can define a stopping time
rule, the details of which are in appendix
\ref{appendix:mc_regressions}. The class below from the module
\verb|ppf.pricer.monte_carlo_helper| manages the lifecycle of the
stopping time rule. In the constructor we initialise the indicator on
all paths to minus one, where minus one means don't exercise. 
\begin{verbatim}
class exercise_helper:
  def __init__(self, num_sims):
    self.__num_sims = num_sims
    self.__last_cfs = numpy.zeros((num_sims))
    self.__indicator = numpy.zeros((num_sims))
    self.__indicator.fill(-1)
\end{verbatim}
In the \verb|update_indicator| method we update the value of the indicator to
the current exercise time, represented by \verb|at|, on all paths
where the pickup value from the regression is positive. 
\begin{verbatim}
class exercise_helper:
  def update_indicator(self, at, vs, fo):
    regression_value = evaluate_regression(vs, fo)
    for i in range(self.__num_sims):
      if self.__indicator[i] < 0:
        if regression_value[i] > 0:
          self.__indicator[i] = at
        else:
          self.__indicator[i] = -1
\end{verbatim}
The class also
provides an implementation of the \verb|max| operator. At each
exercise time, \verb|at|, the \verb|max| operator does nothing more
than check to see if we have exercised on or before the exercise time.
On those paths where this is true we return the previous holding
value, \verb|hv|, plus the intermediate cash flows between the current
exercise time and the previous exercise time; otherwise we return the
holding value. 
\begin{verbatim}
class exercise_helper:
  def max(self, at, cfs, hv):
    res = numpy.zeros((self.__num_sims))
    for i in range(self.__num_sims):
      value = 0.0
      if self.__indicator[i] > 0 and self.__indicator[i] <= at + 0.01:
        value = cfs[i]-self.__last_cfs[i] # cash flow(s) between exercise dates
      res[i] = hv[i]+value      
    self.__last_cfs = cfs.copy() # deep copy
    return res    
\end{verbatim}
Because we move forwards in time when pricing using
Monte-Carlo, the handling of the cash flows is a bit tricky. We begin
by initialising the cashflows to the sum of all cash flows paying on
or before the first exercise date. This can be done by invoking the
\verb|set_last_cfs| method. 
\begin{verbatim}
class exercise_helper:
  def set_last_cfs(self, cfs):
    self.__last_cfs = cfs.copy() # deep copy 
\end{verbatim}
Then at the end of every call to
\verb|max| we update the values of the cash flows to the
new sum of all cash flows paying on or before the next exercise date
(or the end of the trade). Note that since we need to maintain a copy
of the value of cashflows we have to use the \verb|copy| method of
NumPy arrays, otherwise we would just get a reference.

In extending the Monte-Carlo pricing to handle callable instruments we
have had to add two more methods to the controller class. The methods
are illustrated below. The first method \verb|numeraire| delegates to
the fill component of the model to calculate the numeraire at a
specified time \verb|t|. Similarly, the second method
\verb|explanatory_variables| delegates to the exercise component of
the model to calculate the explanatory variables at a specified time
\verb|t|. One thing to note is the use of the \verb|pay_currency|
method on the event. This method either returns the pay currency for a
flow event or the fee currency for an exercise event.
\begin{verbatim}
  def numeraire(self, t):
    if t < 0:
      raise RuntimeError, "attempting to call 'numeraire' in the past"
    fill = self.__model.fill()
    requestor = self.__model.requestor()
    state = self.__model.state().fill(t, requestor, self.__env)
    return fill.numeraire(t, self.__event.pay_currency(), self.__env\
                          , requestor, state)

  def explanatory_variables(self, t):
    if t < 0:
      raise RuntimeError, "attempting to call 'explanatory_variables' in the past"
    fill = self.__model.fill()
    requestor = self.__model.requestor()
    state = self.__model.state().fill(t, requestor, self.__env)
    exercise = self.__model.exercise()
    return exercise(t, fill, state, requestor, self.__env)
\end{verbatim}

The full unedited version of the Monte-Carlo pricer is in the \\
\verb|ppf.pricer.monte_carlo_pricer| module. For
pricing callable structures you need two instances of the model: one
for use in the exercise boundary estimation; and the other for
pricing. Both instances will have different seeds for the random
number generator(s) to prevent any foresight bias, see
\cite{article:FRIES05} for more details. Furthermore, the estimation
of the exercise boundary is usually carried out using fewer paths than
the actual pricing, so the models will normally have a different number
of simulations. As a consequence of the need for two models, the
constructor of the Monte-Carlo pricer has been altered to take in an
optional second model used in the estimation of the exercise
boundary. 
\begin{verbatim}
class monte_carlo_pricer:
  def __init__(self, trade, model, env, symbol_table_listener = None\
    , regression_model = None):
    self.__trade = trade
    self.__model = model
    self.__env = env
    self.__symbol_table_listener = symbol_table_listener
    self.__regression_model = regression_model
    self.__fitted_fos = None
    self.__exercise_helper = None
    # check no stubs
    trade_utils.enforce_no_exercise_stubs(trade)
    # create timeline
    self.__timeline = timeline(trade, env.pricing_date())   
    # check regression model present if callable
    if self.__trade.has_exercise_schedule() and self.__regression_model == None:
      raise RuntimeError, "exercise schedule present but no 'regression model'"

  def __symbol_listener_(self, t, symbol, value):
    if self.__symbol_table_listener:
      self.__symbol_table_listener(t, symbol, value, self.__model, self.__env)
\end{verbatim}
The main new block of code is in the
\verb|__exercise_boundary_regression| method. This method only gets
called if there is a second model present. If the method is called, then 
we begin by constructing the controller, initialising some symbols in the 
symbol table and inserting the symbols contained in \verb|symbol_value_pairs_to_add| 
into the symbol table.
\begin{verbatim}
class monte_carlo_pricer:
  def __exercise_boundary_regression(self, symbol_value_pairs_to_add):
    num_expl_vars = self.__regression_model.exercise().num_explanatory_variables()
    num_sims = self.__regression_model.state().num_sims()
    num_exercises = self.__timeline.number_of_exercises()
    # create controller
    ctr = controller(self.__trade, self.__regression_model, self.__env, 1.0)
    times = self.__timeline.times()
    from_ = 0.0
    # initialise symbols
    ctr.insert_symbol("underlying", from_)
    # add extra symbols
    if symbol_value_pairs_to_add:
      for symbol_value_pair in symbol_value_pairs_to_add:
        symbol, value = symbol_value_pair
        ctr.insert_symbol(symbol, value)
    cnt = 0
    for l in self.__trade.legs():
      symbol = "leg"+str(cnt)
      ctr.insert_symbol(symbol, from_)      
      cnt += 1
    .
    .
    .
\end{verbatim}
Then we evolve along the timeline calculating the cash flows on the
way; storing at each exercise time the sum of the cash flows up to that
time, the numeraire and explanatory variables. 
\begin{verbatim}
class monte_carlo_pricer:
  def __exercise_boundary_regression(self, symbol_value_pairs_to_add):
    .
    .
    .
    # forward iterate through the timeline
    vs = numpy.zeros([num_exercises, num_sims, num_expl_vars])
    ies = numpy.zeros([num_exercises, num_sims])
    ns = numpy.zeros([num_exercises, num_sims]) # for fees - ignored for present
    normalisation = 1.0/self.__trade.legs()[0].flows()[0].notional()
    ex_cnt = 0
    for time in times:
      to_ = self.__env.relative_date(time)/365.0
      # evolve
      ctr.evolve(from_, to_)
      events = self.__timeline.events(time)
      # evaluate explanatory variables and immediate exercise values
      for event in events:
        # set event on controller
        ctr.set_event(event)
        # evaluate
        if is_exercise_event(event):
          # evaluate underlying  
          underlying = ies[ex_cnt, :]           
          cnt = 0
          for l in self.__trade.legs():
            underlying += ctr.retrieve_symbol("leg"+str(cnt))         
            cnt += 1   
          underlying *= self.__trade.exercise_type()       
          underlying *= normalisation
          # evaluate explanatory variables and numeraire
          ns[ex_cnt, :] = ctr.numeraire(to_)
          vs[ex_cnt, :] = ctr.explanatory_variables(to_)
          ex_cnt += 1
      # evaluate cash flows
      for event in events:
        # set event on controller
        ctr.set_event(event)
        # evaluate
        if is_pay_event(event):
          # evaluate payoff
          cpn = ctr(to_)
          symbol = "leg"+str(event.leg_id())
          leg_pv = ctr.retrieve_symbol(symbol) 
          leg_pv += cpn        
          self.__symbol_listener_(to_, symbol, leg_pv)
          ctr.update_symbol(symbol, leg_pv, to_)                      
      from_ = to_
      .
      .
      .
\end{verbatim}
Once we have all of
this information we compute the immediate exercise values by
subtracting from the total sum of all cash flows each of the stored
sum of cash flows in turn. The regression is then carried out via an
invocation of the free function \verb|pickup_value_regression|. The
method ends with the creation of an instance of the
\verb|exercise_helper| class, which will be used in the actual pricing
of the callable structure.
\begin{verbatim}
class monte_carlo_pricer:
  def __exercise_boundary_regression(self, symbol_value_pairs_to_add):
    .
    .
    .
    # final immediate exercise value
    underlying = ctr.retrieve_symbol("underlying")
    cnt = 0
    for l in self.__trade.legs():
      underlying += ctr.retrieve_symbol("leg"+str(cnt))         
      cnt += 1          
    underlying *= self.__trade.exercise_type()   
    underlying *= normalisation
    # subtract immediate exercise values from final
    for i in range(num_exercises):
      ies[i, :]=underlying-ies[i, :]   
    # perform regression
    self.__fitted_fos = pickup_value_regression(ies, ns, vs)
    # create helper class for dealing with exercise indicator - note number of simulations
    self.__exercise_helper = exercise_helper(self.__model.state().num_sims()) 
\end{verbatim}

The function call operator hasn't had to change too much from the
non-callable version. The main differences are the careful order in
which we handle the different event types and the subsequent calls
onto the instance of the \verb|exercise_helper| class to determine
whether to exercise or not. Again we will step through the code
highlighting the main features of interest. Just like before, we begin 
by constructing the controller, initialising some symbols in the symbol 
table and inserting the symbols contained in \verb|symbol_value_pairs_to_add| 
into the symbol table. 
\begin{verbatim}      
  def __call__(self, symbol_value_pairs_to_add = None):
    # do regression if required
    if self.__regression_model:
      self.__exercise_boundary_regression(symbol_value_pairs_to_add)
    # create controller
    ctr = controller(self.__trade, self.__model, self.__env, 1.0)
    times = self.__timeline.times()
    from_ = 0.0
    # initialise symbols
    ctr.insert_symbol("underlying", from_)
    ctr.insert_symbol("berm", from_)
    # add extra symbols
    if symbol_value_pairs_to_add:
      for symbol_value_pair in symbol_value_pairs_to_add:
        symbol, value = symbol_value_pair
        ctr.insert_symbol(symbol, value)
    cnt = 0
    for l in self.__trade.legs():
      symbol = "leg"+str(cnt)
      ctr.insert_symbol(symbol, from_)      
      cnt += 1
    .
    .
    .
\end{verbatim}
Next we evolve through the timeline calculating the cash flows on the
way. The difference now is that we have to initialise the instance of
the \verb|exercise_helper| class with the sum of cash flows paid on or
before the first exercise time. Consequently we have split what was a
single loop over all events at a particular time on the timeline into
three separate loops. In the first loop we check for the first
exercise event.
\begin{verbatim}
  def __call__(self, symbol_value_pairs_to_add = None):
    .
    .
    .
    # forward iterate through the timeline
    ex_cnt = 0
    for time in times:
      to_ = self.__env.relative_date(time)/365.0
      # evolve
      ctr.evolve(from_, to_)
      events = self.__timeline.events(time)
      # set initial immediate exercise value 
      # - sum of all flows before exercise date
      for event in events:
        if is_exercise_event(event):
          # evaluate underlying             
          underlying = ctr.retrieve_symbol("underlying")
          underlying *= 0
          cnt = 0
          for l in self.__trade.legs():
            underlying += ctr.retrieve_symbol("leg"+str(cnt))         
            cnt += 1
          if ex_cnt == 0:
            self.__exercise_helper.set_last_cfs(\
              self.__trade.exercise_type()*underlying)
          self.__symbol_listener_(to_, "underlying", underlying)
    .
    .
    .
\end{verbatim}
In the second loop we calculate the cash flows as
before
\begin{verbatim}      
  def __call__(self, symbol_value_pairs_to_add = None):
    .
    .
    .
     # evaluate cash flows
     for event in events:
       # set event on controller
       ctr.set_event(event)
       # evaluate
       if is_pay_event(event):
         # evaluate payoff
         cpn = ctr(to_)
         symbol = "leg"+str(event.leg_id())
         leg_pv = ctr.retrieve_symbol(symbol) 
         leg_pv += cpn        
         self.__symbol_listener_(to_, symbol, leg_pv)
         ctr.update_symbol(symbol, leg_pv, to_)                   
   .
   .
   .
\end{verbatim}
and in the final loop we check to see if we have exercised or
not by calling the \verb|update_indicator| method of the instance of
the \verb|exercise_helper| class. The \verb|max| method is also
invoked in the final loop, thereby updating the callable value with the
cash flows paid between the current exercise time and the previous
exercise time. 
\begin{verbatim}      
  def __call__(self, symbol_value_pairs_to_add = None):
    .
    .
    .
      # evaluate exercise using regression   
      for event in events:
        # set event on controller
        ctr.set_event(event)
        # evaluate
        if is_exercise_event(event):
          # evaluate underlying             
          underlying = ctr.retrieve_symbol("underlying")
          underlying *= 0
          cnt = 0
          for l in self.__trade.legs():
            underlying += ctr.retrieve_symbol("leg"+str(cnt))         
            cnt += 1
          # explanatory variables and numeraire
          ns = ctr.numeraire(to_) # for fees but not used at present
          vs = ctr.explanatory_variables(to_)
          # evaluate regression
          self.__exercise_helper.update_indicator(to_, vs, self.__fitted_fos[ex_cnt])
          berm = ctr.retrieve_symbol("berm")
          berm = self.__exercise_helper.max(to_, self.__trade.exercise_type()*underlying, berm)
          # update symbols
          ctr.update_symbol("underlying", underlying, to_)
          ctr.update_symbol("berm", berm, to_)
          ex_cnt = ex_cnt+1
      from_ = to_
    .
    .
    .
\end{verbatim}
At the end of the loop over the timeline we have to call the
\verb|max| operator of the \verb|exercise_helper| class once more to
ensure that the final cash flows paying after the last exercise time
are added to the callable value, the symbol \verb|berm|, on those
paths that have exercised before the end of the trade.
\begin{verbatim}      
  def __call__(self, symbol_value_pairs_to_add = None):
    .
    .
    .
    # calculate pv
    underlying = ctr.retrieve_symbol("underlying")
    underlying *= 0
    cnt = 0
    for l in self.__trade.legs():
      underlying += ctr.retrieve_symbol("leg"+str(cnt))         
      cnt += 1
    self.__symbol_listener_(to_, "underlying", underlying)
    ctr.update_symbol("underlying", underlying, to_)
    if self.__regression_model:
      berm = ctr.retrieve_symbol("berm")
      berm = self.__exercise_helper.max(to_, \
               self.__trade.exercise_type()*underlying, berm)
      ctr.update_symbol("berm", berm, to_)
    pv = 0
    if self.__trade.has_exercise_schedule():
      if self.__trade.exercise_type() == exercise_type.callable:
        pv = ctr.retrieve_symbol("berm").mean()
      else:
        pv = ctr.retrieve_symbol("underlying").mean() \
               +ctr.retrieve_symbol("berm").mean()
    else:
      pv = ctr.retrieve_symbol("underlying").mean()
    return pv
\end{verbatim}

The above pricing framework is generic and makes few assumptions on
either the model or the underlying numerical container. One obvious
caveat to this is that the pricing framework doesn't handle stubs, the
treatment of which is beyond the scope of this book. As a final
comment, the inclusion of fees into the framework is left an exercise
for the reader.

\section{Concluding Remarks}
In this chapter we have developed two pricing frameworks: a lattice
pricing framework for pricing non-path dependent callable structures;
and a Monte-Carlo pricing framework for pricing both non-callable and
callable path-dependent structures. Throught the exposition we have
only concentrated on the pricing and not the risk. By risk we mean the
greeks. It is well known in financial mathematics that any poor
treatment of discontinuties in the payoff is amplified in the greeks,
usually to such an extent that the noise in the greeks renders them of
no practical use. Consequently there have been many papers published on
this topic by both academics and practitioners.

When discussing the integrator used in the lattice pricing framework
to perform the conditional expectations, we took great care in the way
we dealt with discontinuities. It is possible to extend the
semi-analytic lattice integrator to multi-dimensions provided we
introduce a way of splitting the lattice into portions with the
function being continuous on each portion. Typically the way this is
achieved is by introducing an algebra on indicator functions. The
management of these indicators is quite complicated. An alternative,
and perhaps simpler, approach is to use PDE techniques. As in the
semi-analyic lattice integrator case, we would still need to provide a
mechanism whereby the payoff could be parsed for information about
where potential discontinuities may occur but once we have the
information we can refine the PDE mesh around the discontinuties. For
more information on the application of PDE techniques to finance
consult \cite{book:DJDUFFY} and \cite{book:KOHLLANDGRAF}.

Similarly discontinuities must be treated carefully when pricing using
Monte-Carlo. Many algorithms have been proposed: pathwise derivatives
and likelihood ratio methods to name a few. A form of likelihood ratio
method, called a \textit{partial proxy scheme}, suitable for use with
the Libor Market Model can be found in \cite{article:FRIES07}. In
\cite{article:FRIES06} the authors apply the \textit{partial proxy
scheme} to target redemption notes and demonstrate that the
scheme produces extremely accurate greeks. An application of the
pathwise derivatives method for computing delta is demonstrated in
\cite{article:PITERBARG03} together with the so called \textit{sausage
Monte-Carlo} method for smoothing the greeks.
